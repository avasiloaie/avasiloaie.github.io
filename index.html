
<!DOCTYPE html>
<html>

<link rel="stylesheet" href="style.css">
    
<!-- FONTS -->
<link href="https://fonts.googleapis.com/css?family=Arvo:400,400i,700,700i" rel="stylesheet">
    
<!-- USER INPUT -->
<link rel="stylesheet" href="lib/codemirror.css">
<script src="lib/codemirror.js"></script>
<script src="collections.min.js"></script>
    
<!-- DEPENDENCY ANALYSIS -->
<script src="bundle.js"></script>
<script>
function load_test(nr) {
    var test = [];
    test[1] = `DO I=1,4
	DO J=1,5
    	A(I,J)=A(I,J-1)
    ENDDO
ENDDO
`;
    test[2] = `DO I=1,4
	DO J=1,4
    	A(I,J)=A(I,J+1)
    ENDDO
ENDDO
`;
    test[3] = `DO I=1,3
	DO J=1,3
    	A(I,1)=A(I+10,J+10)
    ENDDO
ENDDO
`;
    test[4] = `DO I=1,5
	DO J=1,5
    	A(I,J)=A(I-1,J-1)+10
    ENDDO
ENDDO
`;
    test[5] = `DO I=1,3
	DO J=1,3
    	A(I,J)=A(2,2)
    ENDDO
ENDDO
`;
    test[6] = `DO I=1,3
	DO J=1,3
    	A(I,J)=A(J,I)
    ENDDO
ENDDO
`;
    test[7] = `DO I=1,3
	DO J=1,3
    	A(I-1,J-1)=A(I,J)
    	A(I,J)=A(I,J-1)
    ENDDO
ENDDO
`;
    test[8] = `DO I=1,5
	DO J=1,5
    	A(I,J-1)=A(I,J)
        A(I,J)=A(I-1,J-1)
    ENDDO
ENDDO
`;
    test[9] = `DO i = 1,100
	x(i) = y(i) + 10
	DO j = 1,100
		b(j) = a(j,n)
		DO k = 1,100
 			a(j+1,k) = b(j)+c(j,k)
		ENDDO
		y(i+j) = a(j+1,n)
	ENDDO
ENDDO
`;
    $editor.setValue(test[nr]);
}
</script>
    
<!-- GRAPH RENDERING -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css">

<!-- CHROMA -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.2/jquery.min.js"></script>
<script>

var colors = new Array(
  //[62,35,255],
  //[60,255,60],
  //[255,35,98],
  //[45,175,230],
  //[255,0,255],
  //[255,128,0]
  [255,108,28],
  [232,54,48],
  [255,52,178],
  [255,170,38]);

var step = 0;
//color table indices for: 
// current color left
// next color left
// current color right
// next color right
var colorIndices = [0,1,2,3];

//transition speed
var gradientSpeed = 0.0003;

function updateGradient()
{
  
  if ( $===undefined ) return;
  
var c0_0 = colors[colorIndices[0]];
var c0_1 = colors[colorIndices[1]];
var c1_0 = colors[colorIndices[2]];
var c1_1 = colors[colorIndices[3]];

var istep = 1 - step;
var r1 = Math.round(istep * c0_0[0] + step * c0_1[0]);
var g1 = Math.round(istep * c0_0[1] + step * c0_1[1]);
var b1 = Math.round(istep * c0_0[2] + step * c0_1[2]);
var color1 = "rgb("+r1+","+g1+","+b1+")";

var r2 = Math.round(istep * c1_0[0] + step * c1_1[0]);
var g2 = Math.round(istep * c1_0[1] + step * c1_1[1]);
var b2 = Math.round(istep * c1_0[2] + step * c1_1[2]);
var color2 = "rgb("+r2+","+g2+","+b2+")";

 $('#header').css({
   background: "-webkit-gradient(linear, left top, right top, from("+color1+"), to("+color2+"))"}).css({
    background: "-moz-linear-gradient(left, "+color1+" 0%, "+color2+" 100%)"});
  
  step += gradientSpeed;
  if ( step >= 1 )
  {
    step %= 1;
    colorIndices[0] = colorIndices[1];
    colorIndices[2] = colorIndices[3];
    
    //pick two new target color indices
    //do not pick the same as the current one
    colorIndices[1] = ( colorIndices[1] + Math.floor( 1 + Math.random() * (colors.length - 1))) % colors.length;
    colorIndices[3] = ( colorIndices[3] + Math.floor( 1 + Math.random() * (colors.length - 1))) % colors.length;
    
  }
}

setInterval(updateGradient,10);
</script>
    
<style type="text/css">
    #mynetwork {
        width: 100%;
        height: 604px;
        border: 2px solid lightgray;
        display:inline-block;
        margin:10px 0px 10px 0;
    }
</style>
    
<body>
    
<div id="header">
    <div id="header_left">
        <div id="title">Compiler Dependency</div>
        <div id="desc">> Sandbox Tool</div>
    </div>
    <div id="header_right">
        <ul>
            <li><a href="">Sample Page 1</a></li>
            <li><a href="">Sample Page 2</a></li>
            <li><a href="">Sample Page 3</a></li>
            <li><a href="">Sample Page 4</a></li>
        </ul>
    </div>
</div>
    
<div id="wrapper">
    
<div id="editor">
    <div id="code"></div>
    <button id="run_button">Run</button>
    <div include="form-input-select()">
        <select id ="option" required>
          <!--
            This is how we can do "placeholder" options.
            note: "required" attribute is on the select
          -->
          <option value=""
                  hidden
          >Routine</option>
      
          <!-- normal options -->
          <option value="1">Iteration Space</option>
          <option value="2">Dependency Graph</option>
        </select>
    </div>
    <nav id="primary_nav_wrap">
            <ul>
              <li><a href="#">Load test</a>
                <ul>
                  <li><a href="#">Basic</a>
                    <ul>
                      <li><a href="#" onclick="load_test(1); return false;">RAW</a></li>
                      <li><a href="#" onclick="load_test(2); return false;">WAR</a></li>
                      <li><a href="#" onclick="load_test(3); return false;">WAW</a></li>
                    </ul>
                  </li>
                  <li><a href="#">Iteration Space</a>
                    <ul>
                      <li><a href="#" onclick="load_test(4); return false;">-1,-1</a></li>
                      <li><a href="#" onclick="load_test(5); return false;">One point</a></li>
                      <li><a href="#" onclick="load_test(6); return false;">A(I,J) = A(J,I)</a></li>
                      <li><a href="#" onclick="load_test(7); return false;">Multiple statements</a></li>
                    </ul>
                  </li>
                  <li><a href="#">Dependency Graph</a>
                    <ul>
                      <li><a href="#" onclick="load_test(8); return false;">Two Statements</a></li>
                      <li><a href="#" onclick="load_test(9); return false;">Slide</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
            </nav>
            <div id ="console" style="overflow-y: scroll; height:200px;">
            
            </div>
        
</div>
    
<div id="printer">
    <div id="mynetwork"></div>
    <div id="labels">
        <div id="labels_itspc">
            <div style="display:inline-block; margin-right:10px; font-weight:bold;">Dependencies:</div>
            <div style="width:20px; height:20px; background-color:#FF7C23; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">RAW</div>
            <div style="margin-left:15px; width:20px; height:20px; background-color:#5889FF; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">WAR</div>
            <div style="margin-left:15px; width:20px; height:20px; background-color:red; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">WAW</div>
            <div style="margin-left:15px; width:20px; height:20px; background-color:#B660E8; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">Mixed</div>
        </div>
        <div id="labels_dpgph">
            <div style="display:inline-block; margin-right:10px; font-weight:bold;">Labels:</div>
            <div style="display: inline-block;">δ</div><div style="display:inline-block; margin-left:5px;">RAW</div>
            <div style="margin-left:15px; display: inline-block;">δ⁻¹</div><div style="display:inline-block; margin-left:5px;">WAR</div>
            <div style="margin-left:15px; display: inline-block;">δ⁰</div><div style="display:inline-block; margin-left:5px;">WAW</div>
        </div>
    </div>
</div>
    
    
</div>
<div id="footer"></div>
    
<script type="text/javascript"> 

function add_to_console(line,color) {
        var d = new Date();
        var ul = document.getElementById("console");
        var li = document.createElement("li");
        li.appendChild(document.createTextNode(d.toLocaleTimeString()+": "+line));
        li.style = "color: "+color+";";
        ul.appendChild(li);
        ul.scrollTop = ul.scrollHeight;
    }

add_to_console("App loaded","#c7c7c7");
    
var $editor = CodeMirror(document.getElementById('code'), {
  value: "INPUT CODE HERE...",
  mode:  "javascript",
  lineNumbers: true
});
    
document.getElementById("run_button").addEventListener("click", function(){
    var input = $editor.getValue();
    input += '\n';
    add_to_console('Parsing...','#c7c7c7');
    var ast = parse_routine(input);
    add_to_console('Parsing done','#c7c7c7');

    function Memory(key) {
    //this.id = id;
    //this.indices = indices;
    this.key = key;
}

var tab = 0;
var tab_size = 50;
var line_cnt = 1;

function code_visualizer (ast) {
    for (var i = 0 ; i < ast.stmt_list.length; i ++) {
        code_visualizer_stmt(ast.stmt_list[i]);
    }
}

function code_visualizer_stmt (stmt) {
    if (stmt.type == "do") {
        code_visualizer_do_top(stmt);
        tab += tab_size;
        for (var i = 0; i < do_stmt.stmt_list.length; i ++) {
            code_visualizer_stmt(do_stmt.stmt_list[i]);
        }
        code_visualizer_do_end();

    }
    else if (stmt.type == "assign") {

    }
}

function code_visualizer_do_top(stmt) {
    var div = document.createElement("code_visualizer_line_"+line_cnt++);
    div.innerHTML = "DO "+stmt.it+" = "+stmt.start+","+stmt.end;
}

function code_visualizer_do_end() {
    var div = document.createElement("code_visualizer_line_"+line_cnt++);
    div.innerHTML = "ENDDO";
}

function it_diff(it1, it2) {
    var result = 1;
    var smaller_size = it1.length < it2.length ? it1.length : it2.length;
    for (var i = 0; i < smaller_size; i ++) {
        if (it1[i][1] == it2[i][1]) {
            result++;
        }
        else {
            break;
        }
    }
    if (result == smaller_size + 1) {
        result = -1;
    }
    return result;
}

function evaluate(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;
    var op = expr.op;
    var lhs = expr.lhs;
    var rhs = expr.rhs;

    if ( type == "op" ) {
        if (lhs == null) {
            if (op == "-") return -evaluate(rhs);
            else if (op == "+") return evaluate(rhs);
            // else console.log("Not a valid operation: "+expr);
        }
        else {
            if (op == "+") return evaluate(lhs) + evaluate(rhs);
            else if (op == "-") return evaluate(lhs) - evaluate(rhs);
            else if (op == "*") return evaluate(lhs) * evaluate(rhs);
            else if (op == "/") return evaluate(lhs) / evaluate(rhs);
            else if (op == "%") return evaluate(lhs) % evaluate(rhs);
            else if (op == ".LT.") return evaluate(lhs) < evaluate(rhs);
            else if (op == ".LE.") return evaluate(lhs) <= evaluate(rhs);
            else if (op == ".GT.") return evaluate(lhs) > evaluate(rhs);
            else if (op == ".GE.") return evaluate(lhs) >= evaluate(rhs);
            else if (op == ".EQ.") return evaluate(lhs) == evaluate(rhs);
            else if (op == ".NE.") return evaluate(lhs) != evaluate(rhs);
            else if (op == ".OR.") return evaluate(lhs) || evaluate(rhs);
            else if (op == ".AND.") return evaluate(lhs) && evaluate(rhs);
            //else console.log("Not a valid operation: "+expr);
        }
    }
    else if ( type == "val" ) {
        return expr.val;
    }
    else if (type == "var" ) {
        if (iterators.has(expr.variable)) return iterators.get(expr.variable);
        else return 0;
    }
    else if (type == "array") {
        return 0;
    }
    else {
        //console.log("Not a valid expr: "+expr); 
    }
}

function evaluate_array(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;
    var op = expr.op;
    var lhs = expr.lhs;
    var rhs = expr.rhs;

    if ( type == "op" ) {
        if (lhs == null) {
            if (op == "-") return -evaluate_array(rhs);
            else if (op == "+") return evaluate_array(rhs);
            // else console.log("Not a valid operation: "+expr);
        }
        else {
            if (op == "+") return evaluate_array(lhs) + evaluate_array(rhs);
            else if (op == "-") return evaluate_array(lhs) - evaluate_array(rhs);
            else if (op == "*") return evaluate_array(lhs) * evaluate_array(rhs);
            else if (op == "/") return evaluate_array(lhs) / evaluate_array(rhs);
            else if (op == "%") return evaluate_array(lhs) % evaluate_array(rhs);
            //else console.log("Not a valid operation: "+expr);
        }
    }
    else if ( type == "val" ) {
        return expr.val;
    }
    else if (type == "var" ) {
        if (iterators.has(expr.variable)) return iterators.get(expr.variable);
        else {
            stop_the_program = true;
            variables_in_array.push(expr.variable);
            return 0;
        }
    }
    else if (type == "array") {
        variables_in_array.push(expr.id);
        stop_the_program = true;
        return 0;
    }
    else {
        //console.log("Not a valid expr: "+expr); 
    }
}

function evaluate_iterator(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;
    var op = expr.op;
    var lhs = expr.lhs;
    var rhs = expr.rhs;

    if ( type == "op" ) {
        if (lhs == null) {
            if (op == "-") return -evaluate_iterator(rhs);
            else if (op == "+") return evaluate_iterator(rhs);
            // else console.log("Not a valid operation: "+expr);
        }
        else {
            if (op == "+") return evaluate_iterator(lhs) + evaluate_iterator(rhs);
            else if (op == "-") return evaluate_iterator(lhs) - evaluate_iterator(rhs);
            else if (op == "*") return evaluate_iterator(lhs) * evaluate_iterator(rhs);
            else if (op == "/") return evaluate_iterator(lhs) / evaluate_iterator(rhs);
            else if (op == "%") return evaluate_iterator(lhs) % evaluate_iterator(rhs);
            //else console.log("Not a valid operation: "+expr);
        }
    }
    else if ( type == "val" ) {
        return expr.val;
    }
    else if (type == "var" ) {
        if (iterators.has(expr.variable)) return iterators.get(expr.variable);
        else {
            stop_the_program = true;
            variables_in_iterator.push(expr.variable);
            return 0;
        }
    }
    else if (type == "array") {
        stop_the_program = true;
        variables_in_iterator.push(expr.variable);
        return 0;
    }
    else {
        //console.log("Not a valid expr: "+expr); 
    }
}

function simulate_expr(expr,side) {
    if (expr.type == "array") {
        var memory = get_memory(expr).key;
        if (option == 2) {
            if (side == "lhs") {
                // testing dependency
                if (writes.has(memory)) {
                    var m = writes.get(memory).entriesArray();
                    for (var i = 0; i < m.length; i ++) {
                        if (!waw_map.has([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString())) {
                            waw.push([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())]);
                            waw_map.set([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString(),1);
                        }
                        if (!waw_map.has([m[i][0],current_stmt,it_diff(iterators.entriesArray(),m[i][1])].toString())) {
                            waw.push([m[i][0],current_stmt,it_diff(iterators.entriesArray(),m[i][1])]);
                            waw_map.set([m[i][0],current_stmt,it_diff(iterators.entriesArray(),m[i][1])].toString(),1);
                        }
                    }
                }

                if (reads.has(memory)) {
                    var m = reads.get(memory).entriesArray();
                    for (var i = 0; i < m.length; i ++) {
                        if (!war_map.has([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString())) {
                            war.push([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())]);
                            war_map.set([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString(),1);
                        }
                    }
                }

                // adding write
                if (writes.has(memory)) {
                    var m = writes.get(memory);
                    if (!m.has(current_stmt)) {
                        m.set(current_stmt,iterators.entriesArray());
                    }
                }
                else {
                    var m = new Map();
                    m.set(current_stmt,iterators.entriesArray());
                    writes.set(memory,m);
                }
                reads.delete(memory);
            }
            else if (side == "rhs") {
                // testing dependency
                if (writes.has(memory)) {
                    var m = writes.get(memory).entriesArray();
                    for (var i = 0; i < m.length; i ++) {
                        if (!raw_map.has([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString())) {
                            raw.push([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())]);
                            raw_map.set([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString(),1);
                        }
                    }
                }

                // adding read
                if (reads.has(memory)) {
                    var m = reads.get(memory);
                    if (!m.has(current_stmt)) {
                        m.set(current_stmt,iterators.entriesArray());
                    }
                }
                else {
                    var m = new Map();
                    m.set(current_stmt,iterators.entriesArray());
                    reads.set(memory,m);
                }
            }
        }
        else {
            if (side == "lhs") {
                // testing dependency
                if (writes_it.has(memory)) {
                    var m = writes_it.get(memory);
                    waw_it.push([m,iterators.entriesArray()]);
                }

                if (reads_it.has(memory)) {
                    var m = reads_it.get(memory);
                    for (var i = 0; i < m.length; i ++) {
                        war_it.push([iterators.entriesArray(),m[i]]);
                    }
                }

                // adding write
                writes_it.set(memory,iterators.entriesArray());
                reads_it.delete(memory);
            }
            else if (side == "rhs") {
                // testing dependency
                if (writes_it.has(memory)) {
                    var m = writes_it.get(memory);
                    raw_it.push([m,iterators.entriesArray()]);
                }

                // adding read
                if (reads_it.has(memory)) {
                    var m = reads_it.get(memory);
                }
                else {
                    var m = new Array();
                    reads_it.set(memory,m);
                }
                m.push(iterators.entriesArray());
            }
        }
    }
    else if (expr.type == "op") {
        simulate_expr(expr.lhs,side);
        simulate_expr(expr.rhs,side);
    }
}

function simulate_stmts(stmt_list) {
    for (var i = 0; i < stmt_list.length; i++) {
        var stmt = stmt_list[i];
        if (stmt.type == "do") {
            simulate_do(stmt);
        }
        else if (stmt.type == "assign") {
            current_stmt = stmt.nr;
            simulate_expr(stmt.rhs,"rhs");
            simulate_expr(stmt.lhs,"lhs");
        }
        else if (stmt.type == "if") {
            if (evaluate(stmt.expr)) {
                simulate_stmts(stmt.if_part);
            }
            else if (stmt.else_if_part != null) {
                for (i = 0; i < stmt.else_if_part.else_if_list.length; i ++) {
                    if (evaluate(stmt.else_if_part.else_if_list[i].expr)) {
                        simulate_stmts(stmt.else_if_part.else_if_list[i].stmt_list);
                        break;
                    }
                }
            }
            else if (stmt.else_part != null) {
                simulate_stmts(stmt.else_part.stmt_list);
            }
        }
    }
}

function simulate_do(do_stmt) {
    var it = do_stmt.it;
    iterators.set(it,evaluate_iterator(do_stmt.start));
    var step;
    if (do_stmt.step == null) step = 1;
    else { step = evaluate_iterator(do_stmt.step); }
    deepness++;
    if (deepness > 2 && option == 1) {  too_deep = 1; }
    if (!stop_the_program) { 

    if (iterators.get(it) > evaluate_iterator(do_stmt.end) && too_deep == 0) {
        if (step > 0) { step = -step; }

        while (iterators.get(it) >= evaluate_iterator(do_stmt.end) ) {
            if (option == 1) {
                if (deepness == 1) {
                    iterations_1.push(iterators.entriesArray());
                }
                else {
                    iterations_2.push(iterators.entriesArray());
                }
            }
            simulate_stmts(do_stmt.stmt_list);
            var next_step = iterators.get(it)+step;
            iterators.set(it,next_step);
        }
    }
    else {
        while (iterators.get(it) <= evaluate_iterator(do_stmt.end) ) {
            if (option == 1) {
                if (deepness == 1) {
                    iterations_1.push(iterators.entriesArray());
                }
                else {
                    iterations_2.push(iterators.entriesArray());
                }
            }
            simulate_stmts(do_stmt.stmt_list);
            var next_step = iterators.get(it)+step;
            iterators.set(it,next_step);
        }
    }
    }
    deepness--;
    iterators.delete(it);
}

function get_memory(array_call) { // eg A(i,j) with i = 5, j = 2 -> MEM(A:5,2)
    var id = array_call.id;
    var indices = [];
    var key = "";

    var key = id + ":";

    for (var i = 0; i < array_call.index_list.length; i++) {
        current_index = evaluate_array(array_call.index_list[i],true);
        indices.push(current_index);
        key += current_index + ",";
    }

    key = key.substring(0,key.length-1);

    return new Memory(key);
}

function run_simulation(ast) {
    simulate_stmts(ast.stmt_list);
}

function calculate_graph_point() {
    var node_itself = [];
    var distance_in_between = [];

    if (max_deepness == 1) {
        diff = iterations_1.length-1;
        space_per_node = Math.floor((width*0.9)/(diff+1));
        node_itself[0] = Math.ceil(space_per_node*0.7);
        distance_in_between[0] = Math.floor(space_per_node*0.3);
        return [node_itself[0],distance_in_between[0]];
    }
    else if (max_deepness == 2) {
        diff = iterations_1.length-1;
        space_per_node = Math.floor((height*0.9)/(diff+1));
        node_itself[0] = Math.ceil(space_per_node*0.4);
        distance_in_between[0] = Math.floor(space_per_node*0.6);
        diff = (iterations_2.length/iterations_1.length)-1;
        space_per_node = Math.floor((width*0.9)/(diff+1));
        node_itself[1] = Math.ceil(space_per_node*0.7);
        distance_in_between[1] = Math.floor(space_per_node*0.3);
        return [node_itself,distance_in_between];
    }   
    return null;
}

function get_distance(dep) {
    var arr = new Array();
    var from = dep[0];
    var to = dep[1];
    if (from.length < to.length) {
        for (var i = 0; i < from.length; i++) {
            arr.push(to[i][1]-from[i][1]);
        }
        return arr;
    }
    else {
        for (var i = 0; i < to.length; i ++) {
            arr.push(to[i][1]-from[i][1]);
        }
        return arr;
    }
}

function get_direction(dist) {
    for (var i = 0; i < dist.length; i++) {
        if (dist[i] > 0) dist[i] = '<';
        else if (dist[i] < 0) dist[i] = '>';
        else dist[i] = '=';
    }
    return dist;
}

function get_delta(dep,type) {
    var build = "δ";
    if (type == 'war') {
        build = build + "⁻¹";
    }
    else if (type == 'waw') {
        build = build + "⁰";
    }
    if (dep == -1) {
        build = build + "∞";
    }
    else {
        var sub;
        if (dep == 1) {
            sub = '₁';
        }
        else if (dep == 2) {
            sub = '₂';
        }
        else if (dep == 3) {
            sub = '₃';
        }
        else if (dep == 4) {
            sub = '₄';
        }
        else if (dep == 5) {
            sub = '₅';
        }
        else if (dep == 6) {
            sub = '₆';
        }
        else if (dep == 7) {
            sub = '₇';
        }
        else if (dep == 8) {                           
            sub = '₈';
        }
        else if (dep == 9) {
            sub = '₉';
        }

        build = build + sub;
    }
    return build;
}

    // simulation 
    var iterators = new Map();
    var reads = new Map();
    var writes = new Map();
    var reads_it = new Map();
    var writes_it = new Map();
    var current_stmt = 0;
    var variables_in_array = new Array();
    var variables_in_iterator = new Array();
    var too_deep = 0;
    var iterations_1 = new Array();
    var iterations_2 = new Array();
    var stop_the_program = false;

    // dependencies
    var raw = new Array();
    var war = new Array();
    var waw = new Array();
    var raw_it = new Array();
    var war_it = new Array();
    var waw_it = new Array();
    var raw_map = new Map();
    var war_map = new Map();
    var waw_map = new Map();

    var i;
    var j;
    var k;
    var h;
    var cnt = 1;
    var spacing
    var current_x;
    var current_y;
    var width;
    var height = 604;
    var node_size;
    var graph_links = new Map();
    var multi = new Map();
    var deepness = 0;
    var max_deepness = 0;
    var edges_added = new Map();
    
    var e = document.getElementById('option');
    var option = e.options[e.selectedIndex].value;

    if (option == 1) {
        add_to_console("Running simulation with option: iteration space...",'#c7c7c7');
    }
    else if (option == 2) {
        add_to_console("Running simulation with option: dependency graph...","c7c7c7");
    }

    run_simulation(ast);
    if (variables_in_iterator.length > 0) {
        add_to_console("ERROR [Unknown variable in iterator: "+variables_in_iterator[0]+"]. Use constants or other iterators",'orange');
        option = 99;
    }
    else if (variables_in_array.length > 0) {
        add_to_console("ERROR [Unknown variable in array call: "+variables_in_array[0]+"]. Use constants or iterators",'orange');
        option = 99;
    }
    else if (too_deep == 1) {
        add_to_console("ERROR [Dimensionality too large]. Use 1D or 2D loops for option: iteration space",'orange');
        option = 99;
    }
    else {
        add_to_console("Simulation done",'green');
    }

    if (iterations_1.length != 0) {
        max_deepness = 1;
        if (iterations_2.length != 0) {
            max_deepness = 2;
        }
    }

    // create an array with nodes
    var nodes = new vis.DataSet([]);

    // create an array with edges
    var edges = new vis.DataSet([]);

    // create a network
    var container = document.getElementById('mynetwork');

    // provide the data in the vis format
    var data = {
        nodes: nodes,
        edges: edges
    };

    //nodes.on('*', function (event, properties, senderId) {});

    var width = window.innerWidth - 650 - 15;

    if (option == 1) {
        console.log(waw_it);
        add_to_console("Building iteration space...");
        if (max_deepness == 1 || max_deepness == 2) {
            spacing = calculate_graph_point();
            current_x = (spacing[0]+spacing[1])/2;
            if (max_deepness == 1) {
                node_size = 25 < spacing[0]/2 ? 25 : spacing[0]/2;
                for (i = 0; i < iterations_1.length; i++) {
                    nodes.add({id: iterations_1[i].toString(), label: iterations_1[i][0][1]+"", x: current_x, y: 265, size: node_size});
                    current_x += spacing[0]+spacing[1];
                }
            }
            else if (max_deepness == 2) {
                current_y = -(spacing[0][0]+spacing[1][0])/2;
                if (spacing[0][0] < spacing[0][1]) {
                    node_size = spacing[0][0]/2;
                }
                else {
                    node_size = spacing[0][1]/2;
                }
                node_size = 25 < node_size ? 25 : node_size;
                var rows = iterations_2.length/iterations_1.length;

                for (i = 0; i < iterations_2.length; i++) {
                    if (i % rows == 0) {
                        current_x = (spacing[0][1]+spacing[1][1])/2;
                        current_y += spacing[0][0]+spacing[1][0];
                    }
                    nodes.add({id: iterations_2[i].toString(), label: iterations_2[i][0][1]+","+iterations_2[i][1][1], x: current_x, y: current_y, size: node_size});
                    current_x += spacing[0][1]+spacing[1][1];
                }
            }
        }

        for (i = 0; i < raw_it.length; i ++) {
            edges.add({id: raw_it[i].toString(), from: raw_it[i][0].toString(), to: raw_it[i][1].toString(), label: get_distance(raw_it[i]).toString(),  color: { color: '#FF7C23', highlight: '#FF7C23'}});
            multi.set(raw_it[i].toString(),1);
        }

        for (i = 0; i < war_it.length; i ++) {
            if (multi.get(war_it[i].toString()) == 1) {
                edges.update({id: war_it[i].toString(), color: { color: '#B660E8', highlight: '#B660E8'}});
                multi.set(war_it[i].toString(),10);
            }
            else {
                edges.add({id: war_it[i].toString(), from: war_it[i][0].toString(), to: war_it[i][1].toString(), label: get_distance(war_it[i]).toString(), color: { color: '#5889FF', highlight: '#5889FF'}});
                multi.set(war_it[i].toString(),2);
            }
        }

        for (i = 0; i < waw_it.length; i ++) {
            if (multi.get(waw_it[i].toString()) == 1 || multi.get(waw_it[i].toString()) == 2 ) {
                edges.update({id: waw_it[i].toString(), color: { color: '#B660E8', highlight: '#B660E8'}});
            }
            else {
                edges.add({id: waw_it[i].toString(), from: waw_it[i][0].toString(), to: waw_it[i][1].toString(), label: get_distance(waw_it[i]).toString(), color: { color: 'red', highlight: 'red'}});
            }
        }

        var options = {
        width: width+'px',
        height: height+'px',
        nodes: {
            font: {face: 'Arvo', color: 'white', size: Math.floor(node_size*0.9)},
            color: {
                background: '#888',
                highlight: 'blue'
            },
            shape: 'circle',
            borderWidth: 0
        },
        edges: {
            font: {face: 'Arvo', color: '#444', size: Math.floor(node_size*0.9)},
            smooth: {
                type: 'curvedCW',
                forceDirection: 'none'
            },
            arrows: {
                to: {
                    enabled: true
                }
            },
            color: {
                color: '#333',
                highlight: 'red'
            }
        },
        physics: false,
        interaction: {
            dragNodes: false,
            zoomView: true,
            dragView: true
        }
        };

        var network = new vis.Network(container, data, options);
        network.moveTo({
        position: {x: 0, y: 0},
        offset: {x: -Math.floor(width*0.9/2), y: -Math.floor(height*0.9/2)},
        scale: 1,
        })

        document.getElementById('labels_itspc').style.display = 'inline-block';
        document.getElementById('labels_dpgph').style.display = 'none';
        //document.getElementById('direction_vector').innerHTML = "["+direction+"]";
        add_to_console("Done",'green');
    }

    else if (option == 2) {
        add_to_console("Building dependency graph...");
    for (i = 1; i <= ast.stmt_nr; i++) {
        nodes.add({id: i, label: "S"+i.toString()});
    }

    for (i = 0; i < raw.length; i++) {
        if (edges_added.has(raw[i][0]+","+raw[i][1])) {
            var new_delta = edges_added.get(raw[i][0]+","+raw[i][1])+","+get_delta(raw[i][2],'raw');
            edges.update({id: raw[i][0]+","+raw[i][1], from: raw[i][0], to: raw[i][1], label: new_delta});
            edges_added.set(raw[i][0]+","+raw[i][1],new_delta);
        }
        else {
            var new_delta = get_delta(raw[i][2],'raw');
            edges.add({id: raw[i][0]+","+raw[i][1], from: raw[i][0], to: raw[i][1], label: new_delta });
            edges_added.set(raw[i][0]+","+raw[i][1],new_delta);
        }
    }

    for (i = 0; i < war.length; i++) {
        if (edges_added.has(war[i][0]+","+war[i][1])) {
            var new_delta = edges_added.get(war[i][0]+","+war[i][1])+","+get_delta(war[i][2],'war');
            edges.update({id: war[i][0]+","+war[i][1], from: war[i][0], to: war[i][1], label: new_delta});
            edges_added.set(war[i][0]+","+war[i][1],new_delta);
        }
        else {
            var new_delta = get_delta(war[i][2],'war');
            edges.add({id: war[i][0]+","+war[i][1], from: war[i][0], to: war[i][1], label: new_delta });
            edges_added.set(war[i][0]+","+war[i][1],new_delta);
        }
    }

    for (i = 0; i < waw.length; i++) {
        if (edges_added.has(waw[i][0]+","+waw[i][1])) {
            var new_delta = edges_added.get(waw[i][0]+","+waw[i][1])+","+get_delta(waw[i][2],'waw');
            edges.add({id: waw[i][0]+","+waw[i][1], from: waw[i][0], to: waw[i][1], label: new_delta});
            edges_added.set(waw[i][0]+","+waw[i][1],new_delta);
        }
        else {
            var new_delta = get_delta(waw[i][2],'waw');
            edges.add({id: waw[i][0]+","+waw[i][1], from: waw[i][0], to: waw[i][1], label: new_delta });
            edges_added.set(waw[i][0]+","+waw[i][1],new_delta);
        }
    }

    var options = {
        width: width+'px',
        height: height+'px',
        nodes: {
            font: {face: 'Arvo', color: 'white', size: 30},
            color: {
                background: '#888',
                highlight: 'blue',
            },
            margin:10,
            shape: 'circle',
            borderWidth: 0,
        },
        edges: {
            font: {face: 'Arvo', color: '#444', size: 25},
            smooth: {
                type: 'curvedCW',
                forceDirection: 'none'
            },
            arrows: {
                to: {
                    enabled: true
                }
            },
            color: {
                color: '#666',
                highlight: 'red'
            }
        },
        physics: true,
        interaction: {
            dragNodes: true,
            zoomView: true,
            dragView: true
        }
        };

        var network = new vis.Network(container, data, options);
 

        //document.getElementById('labels_dpgph').style.display = 'inline-block';
        document.getElementById('labels_itspc').style.display = 'none';
        add_to_console("Done",'green');
    }

});

    
</script>
    
</body>
</html>