
<!DOCTYPE html>
<html>

<link rel="stylesheet" href="style.css">
    
<!-- FONTS -->
<link href="https://fonts.googleapis.com/css?family=Arvo:400,400i,700,700i" rel="stylesheet">
    
<!-- USER INPUT -->
<link rel="stylesheet" href="lib/codemirror.css">
<link rel="stylesheet" href="webfont.css">
<link type="text/css" rel="stylesheet" href="lib/jquery.qtip.min.css" />

<script type="text/javascript" src="lib/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="lib/jquery.qtip.min.js"></script>
<script src="lib/codemirror.js"></script>
<script src="collections.min.js"></script>
    
<!-- DEPENDENCY ANALYSIS -->
<script src="bundle.js"></script>
<script>
function load_test(nr) {
    var test = [];
    test[1] = `DO I=1,4
	DO J=1,5
    	A(I,J)=A(I,J-1)
    ENDDO
ENDDO
`;
    test[2] = `DO I=1,4
	DO J=1,4
    	A(I,J)=A(I,J+1)
    ENDDO
ENDDO
`;
    test[3] = `DO I=1,3
	DO J=1,3
    	A(I,1)=A(I+10,J+10)
    ENDDO
ENDDO
`;
    test[4] = `DO I=1,5
	DO J=1,5
    	A(I,J)=A(I-1,J-1)+10
    ENDDO
ENDDO
`;
    test[5] = `DO I=1,3
	DO J=1,3
    	A(I,J)=A(2,2)
    ENDDO
ENDDO
`;
    test[6] = `DO I=1,3
	DO J=1,3
    	A(I,J)=A(J,I)
    ENDDO
ENDDO
`;
    test[7] = `DO I=1,3
	DO J=1,3
    	A(I-1,J-1)=A(I,J)
    	A(I,J)=A(I,J-1)
    ENDDO
ENDDO
`;
    test[8] = `DO I=1,5
	DO J=1,5
    	A(I,J-1)=A(I,J)
        A(I,J)=A(I-1,J-1)
    ENDDO
ENDDO
`;
    test[9] = `DO i = 1,100
	x(i) = y(i) + 10
	DO j = 1,100
		b(j) = a(j,n)
		DO k = 1,100
 			a(j+1,k) = b(j)+c(j,k)
		ENDDO
		y(i+j) = a(j+1,n)
	ENDDO
ENDDO
`;
    $editor.setValue(test[nr]);
}
</script>
    
<!-- GRAPH RENDERING -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css">

<!-- CHROMA -->
<!---<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.2/jquery.min.js"></script>-->
<script>

/*var colors = new Array(
  //[62,35,255],
  //[60,255,60],
  //[255,35,98],
  //[45,175,230],
  //[255,0,255],
  //[255,128,0]
  [255,108,28],
  [232,54,48],
  [255,52,178],
  [255,170,38]);

var step = 0;
//color table indices for: 
// current color left
// next color left
// current color right
// next color right
var colorIndices = [0,1,2,3];

//transition speed
//var gradientSpeed = 0.0003;
var gradientSpeed = 0;

function updateGradient()
{
  
  if ( $===undefined ) return;
  
var c0_0 = colors[colorIndices[0]];
var c0_1 = colors[colorIndices[1]];
var c1_0 = colors[colorIndices[2]];
var c1_1 = colors[colorIndices[3]];

var istep = 1 - step;
var r1 = Math.round(istep * c0_0[0] + step * c0_1[0]);
var g1 = Math.round(istep * c0_0[1] + step * c0_1[1]);
var b1 = Math.round(istep * c0_0[2] + step * c0_1[2]);
var color1 = "rgb("+r1+","+g1+","+b1+")";

var r2 = Math.round(istep * c1_0[0] + step * c1_1[0]);
var g2 = Math.round(istep * c1_0[1] + step * c1_1[1]);
var b2 = Math.round(istep * c1_0[2] + step * c1_1[2]);
var color2 = "rgb("+r2+","+g2+","+b2+")";

 $('#header').css({
   background: "-webkit-gradient(linear, left top, right top, from("+color1+"), to("+color2+"))"}).css({
    background: "-moz-linear-gradient(left, "+color1+" 0%, "+color2+" 100%)"});
  
  step += gradientSpeed;
  if ( step >= 1 )
  {
    step %= 1;
    colorIndices[0] = colorIndices[1];
    colorIndices[2] = colorIndices[3];
    
    //pick two new target color indices
    //do not pick the same as the current one
    colorIndices[1] = ( colorIndices[1] + Math.floor( 1 + Math.random() * (colors.length - 1))) % colors.length;
    colorIndices[3] = ( colorIndices[3] + Math.floor( 1 + Math.random() * (colors.length - 1))) % colors.length;
    
  }
}

setInterval(updateGradient,10);*/
</script>
    
<style type="text/css">
    #is_network {
        width: 100%;
        height: 532px;
        /*border: 2px solid lightgray;*/
        display:inline-block;
        /*margin:10px 0px 10px 0;*/
    }
    #dg_network {
        width: 100%;
        height: 529px;
        /*border: 2px solid lightgray;*/
        display:inline-block;
        /*margin:10px 0px 10px 0;*/
    }
</style>
    
<body>
    
<div id="header">
    <div id="header_left">
        <div id="title">Compiler Dependency</div>
        <div id="desc">> Sandbox Tool</div>
    </div>
    <div id="header_right">
        <!--
        <ul>
            <li><a href="">Sample Page 1</a></li>
            <li><a href="">Sample Page 2</a></li>
            <li><a href="">Sample Page 3</a></li>
            <li><a href="">Sample Page 4</a></li>
        </ul>-->
    </div>
</div>
    
<div id="wrapper">
<div id="leftside">
<div id="editor">
    <div id="code"></div>
    <div class="under_code">
    <button id="parse_button" class="my_button"><span class="my_button_icon">~</span><span class="my_button_text">Parse</span></button>
    <nav id="primary_nav_wrap">
            <ul>
              <li><a href="#"><span class="my_button_icon">&#xe020;</span> Load test</a>
                <ul>
                  <li><a href="#">Basic</a>
                    <ul>
                      <li><a href="#" onclick="load_test(1); return false;">RAW</a></li>
                      <li><a href="#" onclick="load_test(2); return false;">WAR</a></li>
                      <li><a href="#" onclick="load_test(3); return false;">WAW</a></li>
                    </ul>
                  </li>
                  <li><a href="#">Iteration Space</a>
                    <ul>
                      <li><a href="#" onclick="load_test(4); return false;">-1,-1</a></li>
                      <li><a href="#" onclick="load_test(5); return false;">One point</a></li>
                      <li><a href="#" onclick="load_test(6); return false;">A(I,J) = A(J,I)</a></li>
                      <li><a href="#" onclick="load_test(7); return false;">Multiple statements</a></li>
                    </ul>
                  </li>
                  <li><a href="#">Dependency Graph</a>
                    <ul>
                      <li><a href="#" onclick="load_test(8); return false;">Two Statements</a></li>
                      <li><a href="#" onclick="load_test(9); return false;">Slide</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
            </nav>
            </div>
        
</div>
<div id="visualizer">
    <div id ="question_vis" class ="question">&#xe03a;</div>
    <div id="tooltip_vis">
            <div class="other">Toggle on/off for simulation and select for dependence tests.
                    <div class="other2">                 
                    <div style="display:block; margin-bottom:5px; margin-top:12px;"><div style="display:inline-block; margin-left:50px;">Off</div><div style="display:inline-block; margin-left:43px">On</div><div style="display:inline-block; margin-left:47px">Selected</div></div>
                    <div style="display:block; margin-bottom:5px;"><div style="display:inline-block; text-align:right; width:39px; ">Stmt</div><div class="stmt" style="display:inline-block; margin-left:10px; font-size:14px">S1</div><div class="stmt" style="display:inline-block; background-color:#666; margin-left:40px; font-size:14px">S1</div><div style="display:inline-block; margin-left:38px">none</div></div>
                    <div style="display:block; margin-bottom:5px;"><div style="display:inline-block; text-align:right; width:39px;">Write</div><div class="vwrite" style="display:inline-block; margin-left:10px; font-size:14px">A(I)</div><div class="vwrite" style="display:inline-block; background-color:blue; margin-left:5px; font-size:14px;">A(I)</div><div class="vwrite" style="display:inline-block; background-color:orange; margin-left:5px; font-size:14px;">A(I)</div></div>      
                    <div style="display:block; margin-bottom:12px;"><div style="display:inline-block; text-align:right; width:39px;">Read</div><div class="vread" style="display:inline-block; margin-left:10px; font-size:14px">A(I)</div><div class="vread" style="display:inline-block; background-color:red; margin-left:5px; font-size:14px;">A(I)</div><div class="vwrite" style="display:inline-block; background-color:orange; margin-left:5px; font-size:14px;">A(I)</div></div>                     
                    </div>              
            They are all toggled <b>on</b> by default.
            </div>
    </div>
    <div id="root"></div>
    <div class="under_code_vis" id="vis_under">
    <button id="edit_button" class="my_button"><span class="my_button_icon">*</span><span class="my_button_text">Edit</span></button>
    <button id="run_button" class="my_button"><span class="my_button_icon">K</span><span class="my_button_text">Run</span><span class="on_demand">on demand</span></button>
    <div id="toggle_thing">
    <span class="toggle_text">or</span>
    <label class="switch">
            <input id="auto_run" type="checkbox" checked>
            <span class="slider round"></span>
    </label>
    <span class="toggle_text">Run automatically</span></div>
    </div>
</div>
<div id ="console" style="overflow-y: scroll; height:200px;"></div>
</div>
    
<div id="printer">
    <!--
    <div id="options_bar">
        <button id="is_button" class="button_tab">Iteration Space</button>
        <button id="dg_button" class="button_tab">Dependency Graph</button>
        <button id="gcd_button" class="button_tab">GCD Test</button>
    </div>
    <div id="mynetwork"></div>-->
    <div class="tab">
        <button class="tablinks" onclick="openTab(event, 'IterationSpace')">Iteration Space</button>
        <button class="tablinks" onclick="openTab(event, 'DependencyGraph')">Dependency Graph</button>
        <button class="tablinks" onclick="openTab(event, 'SubscriptTests')">Subscript Tests</button>
    </div>
    <div id="IterationSpace" class="tabcontent">
        <div id="is_network"></div>
        <div id="is_bottom">
                <div id="labels">
                        <div id="labels_itspc">
                            <div style="display:inline-block; margin-right:10px; font-weight:bold;">Dependencies:</div>
                            <div style="width:20px; height:20px; background-color:#FF7C23; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">RAW</div>
                            <div style="margin-left:15px; width:20px; height:20px; background-color:#5889FF; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">WAR</div>
                            <div style="margin-left:15px; width:20px; height:20px; background-color:red; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">WAW</div>
                            <div style="margin-left:15px; width:20px; height:20px; background-color:#B660E8; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">Mixed</div>
                        </div>
                    </div>
    </div>
    </div>
    <div id="DependencyGraph" class="tabcontent">
        <div id="dg_network"></div>
        <div id="dg_bottom">
            <div id="labels">
                <div id="labels_dpgph">
                        <div style="display:inline-block; margin-right:10px; font-weight:bold;">Dependencies:</div>
                        <div style="display: inline-block;"><span style="font-size:24px;">δ</span></div><div style="display:inline-block; margin-left:5px;">RAW</div>
                        <div style="margin-left:15px; display: inline-block;"><span style="font-size:24px;">δ⁻¹</span></div><div style="display:inline-block; margin-left:5px;">WAR</div>
                        <div style="margin-left:15px; display: inline-block;"><span style="font-size:24px;">δ⁰</span></div><div style="display:inline-block; margin-left:5px;">WAW</div>
                        <div style="margin-left:15px; display: inline-block;"><span style="font-size:24px;">δᵢ</span></div><div style="display:inline-block; margin-left:8px;">subscript <i><b>i</b></i> denotes level of loop carried dependence</div>
                    </div>
            </div>
    </div>                          
    </div>
    <div id="SubscriptTests" class="tabcontent">
        <div class = "nongraph">
        <div class = "st_step" id ="st_step_select">
            <div id ="st_text_select" class="st_text">1. Select array calls for which to analyze subscripts.</div>
            <button id="st_select" class="st_button">Get subscripts</button>
            <div id ="arrs"></div>
        </div>
        <div class = "st_step" style="display:none;" id ="st_step_part">
            <div id = "st_text_part" class="st_text">2. Partition and classify the subscripts.</div>
            <div id="subscripts"></div>
            <button id="st_partition" class="st_button">Partition</button>
        </div>
        <div class = "st_step" style="display:none;" id = "st_step_classify">
            <div class="st_text">3. Classify the partitions into ZIV, SIV, MIV, or COUPLED.</div>
            <div id="partitions"></div>
        </div>
        <div class= "st_step">
            <button id="refresh" class="refresh">Refresh</button>
        </div>
        </div>
    </div>   
</div>
    
<script type="text/javascript">
function openTab(evt, tabname) {
  // Declare all variables
  var i, tabcontent, tablinks;

  // Get all elements with class="tabcontent" and hide them
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }

  // Get all elements with class="tablinks" and remove the class "active"
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }

  // Show the current tab, and add an "active" class to the button that opened the tab
  document.getElementById(tabname).style.display = "block";
  evt.currentTarget.className += " active";
  if (parsed == true) {
    run_active();
  }
}
</script>    


</div>


<div id="footer"></div>
    
<script type="text/javascript"> 

// EDITOR

var $editor = CodeMirror(document.getElementById('code'), {
  value: "INPUT CODE HERE...",
  mode:  "javascript",
  lineNumbers: true
});

// GLOBAL DECLS

var ast;
var tab;
var tab_size = 40;
var line_cnt;
var read_cnt;
var vwrites;
var vreads;
var stmts;
var writes_register = new Map();
var reads_register = new Map();
var stmt_register = new Map();
var writes_enum = new Map();
var reads_enum = new Map();
var visualizer = document.getElementById('visualizer');
var vis_under = document.getElementById('vis_under');
var too_deep = 0;
var change = false;
var parsed = false;
var wrs = new Map();
var selection_mode = false;
var iterators = new Map();
var reads_selected = new Map();
var writes_selected = new Map();

// CONSOLE INIT
function add_to_console(line,color) {
        var d = new Date();
        var ul = document.getElementById("console");
        var li = document.createElement("li");
        li.appendChild(document.createTextNode(d.toLocaleTimeString()+": "+line));
        li.style = "color: "+color+";";
        ul.appendChild(li);
        ul.scrollTop = ul.scrollHeight;
    }

add_to_console("App loaded","#c7c7c7");
// CONSOLE INIT END

// PARSE ACTIVATOR *** ***
document.getElementById("parse_button").addEventListener("click", function(){
    var input = $editor.getValue();
    input += '\n';

// REFRESH ...

// // ROOT
visualizer.removeChild(root);
root = document.createElement('div');
root.id = "root";
visualizer.insertBefore(root,vis_under);

// // COUNTERS

tab = 0;
line_cnt = 0;
vwrites = 0;
vreads = 0;
stmts = 0;
writes_register = new Map();
reads_register = new Map();
stmt_register = new Map();
writes_enum = new Map();
reads_enum = new Map();
too_deep = 0;
selection_mode = false;
iterators = new Map();
reads_selected = new Map();
writes_selected = new Map();

// PARSE 

add_to_console('Parsing...','#c7c7c7');
ast = parse_routine(input);
code_visualizer(ast); // VISUALIZATION
add_event_listeneners(); // LISTENERS
parsed = true;
add_to_console('Parsing done','#c7c7c7');

// PARSE END

// // FUNCTIONS NEEDED FOR VISUALIZATION

function add_event_listeneners() {
    var i;
    for (i = 1; i <= vwrites; i++) {
        document.getElementById("vwrite_"+i).addEventListener("click", function() {
            var i = parseInt(this.id.substring(7,this.id.length));
            if (!selection_mode) { 
                if (writes_register.has(i)) {
                    writes_register.delete(i);
                    this.style.background = "rgba(50, 50, 136, 0.6)";
                }
                else {
                    writes_register.set(i,true);
                    this.style.background = "blue";
                }
                if (document.getElementById("auto_run").checked) {
                    run_active();
                }
                else {
                    change = true;
                }
            }
            else {
                if (writes_selected.has(i)) {
                    writes_selected.delete(i);
                    if (writes_register.has(i)) this.style.background = "blue";
                    else this.style.background = "rgba(50, 50, 136, 0.6)";
                }
                else {
                    if (writes_selected.length == 0 || writes_selected.length == 1 && reads_selected.length == 0) {
                        writes_selected.set(i,true);
                        this.style.background = "orange";
                    }
                }
            }
        });
        writes_register.set(i,true);
        document.getElementById("vwrite_"+i).style.background = "blue";
    }
    for (i = 1; i <= vreads; i++) {
        document.getElementById("vread_"+i).addEventListener("click", function() {
            var i = parseInt(this.id.substring(6,this.id.length));
            if (!selection_mode) {
                if (reads_register.has(i)) {
                    reads_register.delete(i);
                    this.style.background = "rgba(180, 37, 37, 0.65)";
                }
                else {
                    reads_register.set(i,true);
                    this.style.background = "red";
                }
                if (document.getElementById("auto_run").checked) {
                    run_active();
                }
                else {
                    change = true;
                }
            }
            else {
                if (reads_selected.has(i)) {
                    reads_selected.delete(i);
                    if (reads_register.has(i)) this.style.background = "red";
                    else this.style.background = "rgba(180, 37, 37, 0.65)";
                }
                else {
                    if (reads_selected.length == 0) {
                        if (writes_selected.length <= 1) {
                            reads_selected.set(i,true);
                            this.style.background = "orange";
                        }
                    }
                }
            }
        });
        reads_register.set(i,true);
        document.getElementById("vread_"+i).style.background = "red";
    }
    for (i = 1; i <= stmts; i++) {
        document.getElementById("stmt_"+i).addEventListener("click", function() {
            var i = parseInt(this.id.substring(5,this.id.length));
            if (stmt_register.has(i)) {
                stmt_register.delete(i);
                this.style.background = "rgb(167, 165, 165)";
            }
            else {
                stmt_register.set(i,true);
                this.style.background = "#666";
            }
            if (document.getElementById("auto_run").checked) {
                run_active();
            }
            else {
                change = true;
            }
        });
        stmt_register.set(i,true);
        document.getElementById("stmt_"+i).style.background = "#666";
    }
}

function add_tab(node) {
    node.style.marginLeft = (tab*tab_size)+"px";
}

function code_visualizer (ast) {
    for (var i = 0 ; i < ast.stmt_list.length; i ++) {
        root.appendChild(code_visualizer_stmt(ast.stmt_list[i]));
    }
}

function code_visualizer_stmt (stmt) {
    var s = document.createElement('div');
    if (stmt.type == "do") {
        iterators.set(stmt.it,true);
        s.appendChild(code_visualizer_do_top(stmt));
        tab ++;
        if (tab == 3) { too_deep = 1; }
        for (var i = 0; i < stmt.stmt_list.length; i ++) {
            s.appendChild(code_visualizer_stmt(stmt.stmt_list[i]));
        }
        tab --;
        iterators.delete(stmt.it);
        s.appendChild(code_visualizer_do_end());
        return s;
    }
    else if (stmt.type == "assign") {
        s.id = "line_"+(++line_cnt);
        s.innerHTML = '<span class="stmt" id="stmt_'+stmt.nr+'">S'+stmt.nr+'</span> '+code_visualizer_assign(stmt);
        stmts = stmt.nr;
        add_tab(s);
    }
    return s;
}

function code_visualizer_do_top(stmt) {
    var top = document.createElement('div');
    top.id = "line_"+(++line_cnt);
    var x = document.createTextNode("DO "+stmt.it+" = "+code_visualizer_evaluate(stmt.start)[0]+","+code_visualizer_evaluate(stmt.end)[0]);
    top.appendChild(x);
    add_tab(top);
    return top;
}

function code_visualizer_do_end() {
    var end = document.createElement('div');
    end.id = "line_"+(++line_cnt);
    end.textContent = "ENDDO";
    add_tab(end);
    return end;
}

function code_visualizer_assign(stmt) {
    return code_visualizer_evaluate(stmt.lhs,'lhs')[0]+" = "+code_visualizer_evaluate(stmt.rhs,'rhs')[0];
}

function code_visualizer_evaluate(expr,side) {
    if (expr == null) {
        return [null,1];
    }
    else if (expr.type == 'op') {
        var lhs = code_visualizer_evaluate(expr.lhs,side);
        var rhs = code_visualizer_evaluate(expr.rhs,side);
        if (expr.lhs == null) {
            if (expr.op == '-') return ["(-" + rhs[0] + ")",rhs[1]];
            else return [rhs[0],rhs[1]];
        }
        else {
            if (expr.op == '+' || expr.op == '-') {
                return [lhs[0]+expr.op+rhs[0],2];
            }
            else {
                if (lhs[1] == 2 && rhs[1] == 2) {
                    return ["(" + lhs[0] + ")" + expr.op + "(" + rhs[0] + ")",1];
                }
                else if (lhs[1] == 2 && rhs[1] == 1) {
                    return ["(" + lhs[0] + ")" + expr.op + rhs[0],1];
                }
                else if (lhs[1] == 1 && rhs[1] == 2) {
                    return [lhs[0] + expr.op + "(" + rhs[0] + ")",1];
                }
                return [lhs[0]+expr.op+rhs[0],1];
            }
        }
    }
    else if (expr.type == 'val') {
        return [expr.val,1];
    }
    else if (expr.type == 'var') {
        return [expr.variable,1];
    }
    else if (expr.type == 'array') {
        var out = "";
        var c;
        if (side == 'lhs') {
            out += '<span class="vwrite" id="vwrite_'+(++vwrites)+'">';
            expr.write_id = vwrites;
            expr.iterators_at = iterators.entriesArray();
            writes_enum.set(vwrites,expr);
        }
        else if (side == 'rhs') {
            out += '<span class="vread" id="vread_'+(++vreads)+'">';
            expr.read_id = vreads;
            expr.iterators_at = iterators.entriesArray();
            reads_enum.set(vreads,expr);
        }
        out += expr.id+"(";
        expr.index_text = new Array();
        for (var i = 0; i < expr.index_list.length; i++) {
            c = code_visualizer_evaluate_inside(expr.index_list[i])[0];
            expr.index_text.push(c);
            out += c + ",";
        }
        out = out.substring(0,out.length-1);
        return [out+")</span>",1];
    }
}

function code_visualizer_evaluate_inside(expr) {
    if (expr == null) {
        return [null,1];
    }
    else if (expr.type == 'op') {
        var lhs = code_visualizer_evaluate(expr.lhs);
        var rhs = code_visualizer_evaluate(expr.rhs);
        if (expr.lhs == null) {
            if (expr.op == '-') return ["(-" + rhs[0] + ")",rhs[1]];
            else return [rhs[0],rhs[1]];
        }
        else {
            if (expr.op == '+' || expr.op == '-') {
                return [lhs[0]+expr.op+rhs[0],2];
            }
            else {
                if (lhs[1] == 2 && rhs[1] == 2) {
                    return ["(" + lhs[0] + ")" + expr.op + "(" + rhs[0] + ")",1];
                }
                else if (lhs[1] == 2 && rhs[1] == 1) {
                    return ["(" + lhs[0] + ")" + expr.op + rhs[0],1];
                }
                else if (lhs[1] == 1 && rhs[1] == 2) {
                    return [lhs[0] + expr.op + "(" + rhs[0] + ")" ,1];
                }
                return [lhs[0]+expr.op+rhs[0],1];
            }
        }
    }
    else if (expr.type == 'val') {
        return [expr.val,1];
    }
    else if (expr.type == 'var') {
        return [expr.variable,1];
    }
    else if (expr.type == 'array') {
        var out = expr.id+"(";
        for (var i = 0; i < expr.index_list.length; i++) {
            out += code_visualizer_evaluate_inside(expr.index_list[i])[0] + ",";
        }
        out = out.substring(0,out.length-1) + ")";
        return [out,1];
    }
}

// FUNCTIONS NEEDED FOR VISUALIZATION END



// CHANGE ENVIRONMENT 

document.getElementById('editor').style.display = "none";
visualizer.style.display = "block";
run_active();
//options_bar.style.display = "inline-block";

// CHANGE ENVIRONMENT END

});

document.getElementById("edit_button").addEventListener("click", function(){
    document.getElementById('editor').style.display = "block";
    visualizer.style.display = "none";
    //options_bar.style.display = "none";
});




// GLOBALS FOR SIMULATION

    // SIM
    iterators = new Map();
    var reads = new Map();
    var writes = new Map();
    var reads_it = new Map();
    var writes_it = new Map();
    var current_stmt = 0;
    var variables_in_array = new Array();
    var variables_in_iterator = new Array();
    var iterations_1 = new Array();
    var iterations_2 = new Array();
    var stop_the_program = false;
    var clean = false;
    var known_vars = new Map();
    var lhs_incorrect = false;

    // DEPS
    var raw = new Array();
    var war = new Array();
    var waw = new Array();
    var raw_it = new Array();
    var war_it = new Array();
    var waw_it = new Array();
    var raw_map = new Map();
    var war_map = new Map();
    var waw_map = new Map();

    // HELP

    var i;
    var j;
    var k;
    var h;
    var cnt = 1;
    var spacing;
    var current_x;
    var current_y;
    var width;
    var height;
    var node_size;
    var graph_links = new Map();
    var multi = new Map();
    var deepness = 0;
    var max_deepness = 0;
    var edges_added = new Map();
    var network;

// GLOBALS FOR SIMULATION END


// FUNCTIONS FOR SIMULATION *** *** 

function Memory(key) {
    //this.id = id;
    //this.indices = indices;
    this.key = key;
}

function it_diff(it1, it2) {
    var result = 1;
    var smaller_size = it1.length < it2.length ? it1.length : it2.length;
    for (var i = 0; i < smaller_size; i ++) {
        if (it1[i][1] == it2[i][1]) {
            result++;
        }
        else {
            break;
        }
    }
    if (result == smaller_size + 1) {
        result = -1;
    }
    return result;
}

function evaluate(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;
    var op = expr.op;
    var lhs = expr.lhs;
    var rhs = expr.rhs;

    if ( type == "op" ) {
        if (lhs == null) {
            if (op == "-") return -evaluate(rhs);
            else if (op == "+") return evaluate(rhs);
            // else console.log("Not a valid operation: "+expr);
        }
        else {
            if (op == "+") return evaluate(lhs) + evaluate(rhs);
            else if (op == "-") return evaluate(lhs) - evaluate(rhs);
            else if (op == "*") return evaluate(lhs) * evaluate(rhs);
            else if (op == "/") return evaluate(lhs) / evaluate(rhs);
            else if (op == "%") return evaluate(lhs) % evaluate(rhs);
            else if (op == ".LT.") return evaluate(lhs) < evaluate(rhs);
            else if (op == ".LE.") return evaluate(lhs) <= evaluate(rhs);
            else if (op == ".GT.") return evaluate(lhs) > evaluate(rhs);
            else if (op == ".GE.") return evaluate(lhs) >= evaluate(rhs);
            else if (op == ".EQ.") return evaluate(lhs) == evaluate(rhs);
            else if (op == ".NE.") return evaluate(lhs) != evaluate(rhs);
            else if (op == ".OR.") return evaluate(lhs) || evaluate(rhs);
            else if (op == ".AND.") return evaluate(lhs) && evaluate(rhs);
            //else console.log("Not a valid operation: "+expr);
        }
    }
    else if ( type == "val" ) {
        return expr.val;
    }
    else if (type == "var" ) {
        if (iterators.has(expr.variable)) return iterators.get(expr.variable);
        else if (known_vars.has(expr.variable)) return known_vars.get(expr.variable);
        else {
            clean = false;
            return 0;
        }
    }
    else if (type == "array") {
        clean = false;
        if (stmt_register.has(current_stmt)) {
        if (reads_register.has(expr.read_id)) {
            simulate_array(expr);
        } }
        return 0;
    }
    else {
        return 0;
    }
}

function evaluate_left(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;

    if (type == "var") {
        return expr.variable;
    }
    else if (type == "array") {
        clean = false;
        if (stmt_register.has(current_stmt)) {
        if (writes_register.has(expr.write_id)) {
            simulate_array(expr);
        } }
        return 0;
    }
    else {
        clean = false;
        stop_the_program = true;
        lhs_incorrect = true;
    }
}

function evaluate_array(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;
    var op = expr.op;
    var lhs = expr.lhs;
    var rhs = expr.rhs;

    if ( type == "op" ) {
        if (lhs == null) {
            if (op == "-") return -evaluate_array(rhs);
            else if (op == "+") return evaluate_array(rhs);
            // else console.log("Not a valid operation: "+expr);
        }
        else {
            if (op == "+") return evaluate_array(lhs) + evaluate_array(rhs);
            else if (op == "-") return evaluate_array(lhs) - evaluate_array(rhs);
            else if (op == "*") return evaluate_array(lhs) * evaluate_array(rhs);
            else if (op == "/") return evaluate_array(lhs) / evaluate_array(rhs);
            else if (op == "%") return evaluate_array(lhs) % evaluate_array(rhs);
            //else console.log("Not a valid operation: "+expr);
        }
    }
    else if ( type == "val" ) {
        return expr.val;
    }
    else if (type == "var" ) {
        if (iterators.has(expr.variable)) return iterators.get(expr.variable);
        else if (known_vars.has(expr.variable)) return known_vars.get(expr.variable);
        else {
            clean = false;
            stop_the_program = true;
            variables_in_array.push(expr.variable);
            return 0;
        }
    }
    else if (type == "array") {
        variables_in_array.push(expr.id);
        clean = false;
        stop_the_program = true;
        return 0;
    }
    else {
        //console.log("Not a valid expr: "+expr); 
    }
}

function evaluate_iterator(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;
    var op = expr.op;
    var lhs = expr.lhs;
    var rhs = expr.rhs;

    if ( type == "op" ) {
        if (lhs == null) {
            if (op == "-") return -evaluate_iterator(rhs);
            else if (op == "+") return evaluate_iterator(rhs);
            // else console.log("Not a valid operation: "+expr);
        }
        else {
            if (op == "+") return evaluate_iterator(lhs) + evaluate_iterator(rhs);
            else if (op == "-") return evaluate_iterator(lhs) - evaluate_iterator(rhs);
            else if (op == "*") return evaluate_iterator(lhs) * evaluate_iterator(rhs);
            else if (op == "/") return evaluate_iterator(lhs) / evaluate_iterator(rhs);
            else if (op == "%") return evaluate_iterator(lhs) % evaluate_iterator(rhs);
            //else console.log("Not a valid operation: "+expr);
        }
    }
    else if ( type == "val" ) {
        return expr.val;
    }
    else if (type == "var" ) {
        if (iterators.has(expr.variable)) return iterators.get(expr.variable);
        else if (known_vars.has(expr.variable)) return known_vars.get(expr.variable);
        else {
            stop_the_program = true;
            clean = false;
            variables_in_iterator.push(expr.variable);
            return 0;
        }
    }
    else if (type == "array") {
        stop_the_program = true;
        clean = false;
        variables_in_iterator.push(expr.variable);
        return 0;
    }
    else {
        //console.log("Not a valid expr: "+expr); 
    }
}

function simulate_array(expr) {
    if (expr.type == "array") {
        var memory = get_memory(expr).key;
        if (option == 2) {
            if (side == "lhs") {
                // testing dependency
                if (writes.has(memory)) {
                    var m = writes.get(memory).entriesArray();
                    for (var i = 0; i < m.length; i ++) {
                        if (!waw_map.has([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString())) {
                            waw.push([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())]);
                            waw_map.set([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString(),1);
                        }
                        if (!waw_map.has([m[i][0],current_stmt,it_diff(iterators.entriesArray(),m[i][1])].toString())) {
                            waw.push([m[i][0],current_stmt,it_diff(iterators.entriesArray(),m[i][1])]);
                            waw_map.set([m[i][0],current_stmt,it_diff(iterators.entriesArray(),m[i][1])].toString(),1);
                        }
                    }
                }

                if (reads.has(memory)) {
                    var m = reads.get(memory).entriesArray();
                    for (var i = 0; i < m.length; i ++) {
                        if (!war_map.has([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString())) {
                            war.push([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())]);
                            war_map.set([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString(),1);
                        }
                    }
                }

                // adding write
                if (writes.has(memory)) {
                    var m = writes.get(memory);
                    if (!m.has(current_stmt)) {
                        m.set(current_stmt,iterators.entriesArray());
                    }
                }
                else {
                    var m = new Map();
                    m.set(current_stmt,iterators.entriesArray());
                    writes.set(memory,m);
                }
                reads.delete(memory);
            }
            else if (side == "rhs") {
                // testing dependency
                if (writes.has(memory)) {
                    var m = writes.get(memory).entriesArray();
                    for (var i = 0; i < m.length; i ++) {
                        if (!raw_map.has([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString())) {
                            raw.push([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())]);
                            raw_map.set([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString(),1);
                        }
                    }
                }

                // adding read
                if (reads.has(memory)) {
                    var m = reads.get(memory);
                    if (!m.has(current_stmt)) {
                        m.set(current_stmt,iterators.entriesArray());
                    }
                }
                else {
                    var m = new Map();
                    m.set(current_stmt,iterators.entriesArray());
                    reads.set(memory,m);
                }
            }
        }
        else {
            if (side == "lhs") {
                // testing dependency
                if (writes_it.has(memory)) {
                    var m = writes_it.get(memory);
                    waw_it.push([m,iterators.entriesArray()]);
                }

                if (reads_it.has(memory)) {
                    var m = reads_it.get(memory);
                    for (var i = 0; i < m.length; i ++) {
                        war_it.push([iterators.entriesArray(),m[i]]);
                    }
                }

                // adding write
                writes_it.set(memory,iterators.entriesArray());
                reads_it.delete(memory);
            }
            else if (side == "rhs") {
                // testing dependency
                if (writes_it.has(memory)) {
                    var m = writes_it.get(memory);
                    raw_it.push([m,iterators.entriesArray()]);
                }

                // adding read
                if (reads_it.has(memory)) {
                    var m = reads_it.get(memory);
                }
                else {
                    var m = new Array();
                    reads_it.set(memory,m);
                }
                m.push(iterators.entriesArray());
            }
        }
    }
}

function simulate_stmts(stmt_list) {
    for (var i = 0; i < stmt_list.length; i++) {
        var stmt = stmt_list[i];
        if (stmt.type == "do") {
            simulate_do(stmt);
        }
        else if (stmt.type == "assign") {
            current_stmt = stmt.nr;
            clean = true;
            var from;
            var to;
            side = "rhs";
            from = evaluate(stmt.rhs);
            if (clean) {
                side = "lhs";
                to = evaluate_left(stmt.lhs);
                if (clean) {
                    known_vars.set(to,from);
                }
            }
            else {
                side = "lhs";
                to = evaluate_left(stmt.lhs);
            }
        }
        else if (stmt.type == "if") {
            if (evaluate(stmt.expr)) {
                simulate_stmts(stmt.if_part);
            }
            else if (stmt.else_if_part != null) {
                for (i = 0; i < stmt.else_if_part.else_if_list.length; i ++) {
                    if (evaluate(stmt.else_if_part.else_if_list[i].expr)) {
                        simulate_stmts(stmt.else_if_part.else_if_list[i].stmt_list);
                        break;
                    }
                }
            }
            else if (stmt.else_part != null) {
                simulate_stmts(stmt.else_part.stmt_list);
            }
        }
    }
}

function simulate_do(do_stmt) {
    var it = do_stmt.it;
    iterators.set(it,evaluate_iterator(do_stmt.start));
    var step;
    if (do_stmt.step == null) step = 1;
    else { step = evaluate_iterator(do_stmt.step); }
    deepness++;
    //if (deepness > 2 && option == 1) {  too_deep = 1; }
    if (!stop_the_program) { 

    if (iterators.get(it) > evaluate_iterator(do_stmt.end) && too_deep == 0) {
        if (step > 0) { step = -step; }

        while (iterators.get(it) >= evaluate_iterator(do_stmt.end) ) {
            if (option == 1) {
                if (deepness == 1) {
                    iterations_1.push(iterators.entriesArray());
                }
                else {
                    iterations_2.push(iterators.entriesArray());
                }
            }
            simulate_stmts(do_stmt.stmt_list);
            var next_step = iterators.get(it)+step;
            iterators.set(it,next_step);
        }
    }
    else {
        while (iterators.get(it) <= evaluate_iterator(do_stmt.end) ) {
            if (option == 1) {
                if (deepness == 1) {
                    iterations_1.push(iterators.entriesArray());
                }
                else {
                    iterations_2.push(iterators.entriesArray());
                }
            }
            simulate_stmts(do_stmt.stmt_list);
            var next_step = iterators.get(it)+step;
            iterators.set(it,next_step);
        }
    }
    }
    deepness--;
    iterators.delete(it);
}

function get_memory(array_call) { // eg A(i,j) with i = 5, j = 2 -> MEM(A:5,2)
    var id = array_call.id;
    var indices = [];
    var key = "";

    var key = id + ":";

    for (var i = 0; i < array_call.index_list.length; i++) {
        current_index = evaluate_array(array_call.index_list[i],true);
        indices.push(current_index);
        key += current_index + ",";
    }

    key = key.substring(0,key.length-1);

    return new Memory(key);
}

function run_simulation(ast) {
    simulate_stmts(ast.stmt_list);
}

function calculate_graph_point() {
    var node_itself = [];
    var distance_in_between = [];
    var diff;
    if (max_deepness == 1) {
        diff = iterations_1.length-1;
        space_per_node = Math.floor((width*0.9)/(diff+1));
        node_itself[0] = Math.ceil(space_per_node*0.7);
        distance_in_between[0] = Math.floor(space_per_node*0.3);
        return [node_itself[0],distance_in_between[0]];
    }
    else if (max_deepness == 2) {
        diff = iterations_1.length-1;
        space_per_node = Math.floor((height*0.9)/(diff+1));
        node_itself[0] = Math.ceil(space_per_node*0.4);
        distance_in_between[0] = Math.floor(space_per_node*0.6);
        diff = (iterations_2.length/iterations_1.length)-1;
        space_per_node = Math.floor((width*0.9)/(diff+1));
        node_itself[1] = Math.ceil(space_per_node*0.7);
        distance_in_between[1] = Math.floor(space_per_node*0.3);
        return [node_itself,distance_in_between];
    }   
    return null;
}

function get_distance(dep) {
    var arr = new Array();
    var from = dep[0];
    var to = dep[1];
    if (from.length < to.length) {
        for (var i = 0; i < from.length; i++) {
            arr.push(to[i][1]-from[i][1]);
        }
        return arr;
    }
    else {
        for (var i = 0; i < to.length; i ++) {
            arr.push(to[i][1]-from[i][1]);
        }
        return arr;
    }
}

function get_direction(dist) {
    for (var i = 0; i < dist.length; i++) {
        if (dist[i] > 0) dist[i] = '<';
        else if (dist[i] < 0) dist[i] = '>';
        else dist[i] = '=';
    }
    return dist;
}

function get_delta(dep,type) {
    var build = "δ";
    if (type == 'war') {
        build = build + "⁻¹";
    }
    else if (type == 'waw') {
        build = build + "⁰";
    }
    if (dep == -1) {
        build = build + "∞";
    }
    else {
        var sub;
        if (dep == 1) {
            sub = '₁';
        }
        else if (dep == 2) {
            sub = '₂';
        }
        else if (dep == 3) {
            sub = '₃';
        }
        else if (dep == 4) {
            sub = '₄';
        }
        else if (dep == 5) {
            sub = '₅';
        }
        else if (dep == 6) {
            sub = '₆';
        }
        else if (dep == 7) {
            sub = '₇';
        }
        else if (dep == 8) {                           
            sub = '₈';
        }
        else if (dep == 9) {
            sub = '₉';
        }

        build = build + sub;
    }
    return build;
}

/// FUNCTIONS FOR SIMULATION END *** ***



/// SIMULATION

// ITERATION SPACE
function make_iteration_space () {
    add_to_console("Running simulation with option: iteration space...",'#c7c7c7');
    option = 1;

    // REFRESH ...

    iterators = new Map();
    reads = new Map();
    writes = new Map();
    reads_it = new Map();
    writes_it = new Map();
    current_stmt = 0;
    variables_in_array = new Array();
    variables_in_iterator = new Array();
    iterations_1 = new Array();
    iterations_2 = new Array();
    stop_the_program = false;
    clean = false;
    known_vars = new Map();
    lhs_incorrect = false;

    raw = new Array();
    war = new Array();
    waw = new Array();
    raw_it = new Array();
    war_it = new Array();
    waw_it = new Array();
    raw_map = new Map();
    war_map = new Map();
    waw_map = new Map();

    // HELP
    cnt = 1;
    graph_links = new Map();
    multi = new Map();
    deepness = 0;
    max_deepness = 0;
    edges_added = new Map();
    height = 532;

    if (too_deep == 1) {
        add_to_console("ERROR [Dimensionality too large]. Use 1D or 2D loops for option: iteration space",'orange');
    }
    else {
        run_simulation(ast);
        if (lhs_incorrect == true) {
            add_to_console("ERROR [Incorrect assignment]. Assign to variables or arrays",'orange');
        }
        else if (variables_in_iterator.length > 0) {
            add_to_console("ERROR [Unknown variable in iterator: "+variables_in_iterator[0]+"]. Use constants or other iterators",'orange');
        }
        else if (variables_in_array.length > 0) {
            add_to_console("ERROR [Unknown variable in array call: "+variables_in_array[0]+"]. Use constants or iterators",'orange');
        }
        else if (too_deep == 1) {
            add_to_console("ERROR [Dimensionality too large]. Use 1D or 2D loops for option: iteration space",'orange');
        }
        else {
            add_to_console("Simulation done",'green');

            if (iterations_1.length != 0) {
                max_deepness = 1;
                if (iterations_2.length != 0) {
                    max_deepness = 2;
                }
            }

            // GRAPH DECL
            // create an array with nodes
            var nodes = new vis.DataSet([]);

            // create an array with edges
            var edges = new vis.DataSet([]);

            // create a network
            var container = document.getElementById('is_network');

            // provide the data in the vis format
            var data = {
                nodes: nodes,
                edges: edges
            };

            //nodes.on('*', function (event, properties, senderId) {});

            width = window.innerWidth - 650 - 15;

            add_to_console("Building iteration space...");
            if (max_deepness == 1 || max_deepness == 2) {
                spacing = calculate_graph_point();
                current_x = (spacing[0]+spacing[1])/2;
                if (max_deepness == 1) {
                    node_size = 25 < spacing[0]/2 ? 25 : spacing[0]/2;
                    for (i = 0; i < iterations_1.length; i++) {
                        nodes.add({id: iterations_1[i].toString(), label: iterations_1[i][0][1]+"", x: current_x, y: 265, size: node_size});
                        current_x += spacing[0]+spacing[1];
                    }
                }
                else if (max_deepness == 2) {
                    current_y = -(spacing[0][0]+spacing[1][0])/2;
                    if (spacing[0][0] < spacing[0][1]) {
                        node_size = spacing[0][0]/2;
                    }
                    else {
                        node_size = spacing[0][1]/2;
                    }
                    node_size = 25 < node_size ? 25 : node_size;
                    var rows = iterations_2.length/iterations_1.length;

                    for (i = 0; i < iterations_2.length; i++) {
                        if (i % rows == 0) {
                            current_x = (spacing[0][1]+spacing[1][1])/2;
                            current_y += spacing[0][0]+spacing[1][0];
                        }
                        nodes.add({id: iterations_2[i].toString(), label: iterations_2[i][0][1]+","+iterations_2[i][1][1], x: current_x, y: current_y, size: node_size});
                        current_x += spacing[0][1]+spacing[1][1];
                    }
                }
            }

            for (i = 0; i < raw_it.length; i ++) {
                if (!multi.has(raw_it[i].toString())) {
                    edges.add({id: raw_it[i].toString(), from: raw_it[i][0].toString(), to: raw_it[i][1].toString(), label: get_distance(raw_it[i]).toString(),  color: { color: '#FF7C23', highlight: '#FF7C23'}});
                    multi.set(raw_it[i].toString(),1);
                }
            }

            for (i = 0; i < war_it.length; i ++) {
                if (multi.get(war_it[i].toString()) == 1) {
                    edges.update({id: war_it[i].toString(), color: { color: '#B660E8', highlight: '#B660E8'}});
                    multi.set(war_it[i].toString(),10);
                }
                else if (!multi.has(war_it[i].toString())) {
                    edges.add({id: war_it[i].toString(), from: war_it[i][0].toString(), to: war_it[i][1].toString(), label: get_distance(war_it[i]).toString(), color: { color: '#5889FF', highlight: '#5889FF'}});
                    multi.set(war_it[i].toString(),2);
                }
            }

            for (i = 0; i < waw_it.length; i ++) {
                if (multi.get(waw_it[i].toString()) == 1 || multi.get(waw_it[i].toString()) == 2 ) {
                    edges.update({id: waw_it[i].toString(), color: { color: '#B660E8', highlight: '#B660E8'}});
                }
                else if (!multi.has(waw_it[i].toString())) {
                    edges.add({id: waw_it[i].toString(), from: waw_it[i][0].toString(), to: waw_it[i][1].toString(), label: get_distance(waw_it[i]).toString(), color: { color: 'red', highlight: 'red'}});
                }
            }

            var options = {
            width: width+'px',
            height: height+'px',
            nodes: {
                font: {face: 'Arvo', color: 'white', size: Math.floor(node_size*0.9)},
                color: {
                    background: '#888',
                    highlight: 'blue'
                },
                shape: 'circle',
                borderWidth: 0
            },
            edges: {
                font: {face: 'Arvo', color: '#444', size: Math.floor(node_size*0.9)},
                smooth: {
                    type: 'curvedCW',
                    forceDirection: 'none'
                },
                arrows: {
                    to: {
                        enabled: true
                    }
                },
                color: {
                    color: '#333',
                    highlight: 'red'
                }
            },
            physics: false,
            interaction: {
                dragNodes: false,
                zoomView: true,
                dragView: true
            }
            };

            network = new vis.Network(container, data, options);
            network.moveTo({
            position: {x: 0, y: 0},
            offset: {x: -Math.floor(width*0.9/2), y: -Math.floor(height*0.9/2)},
            scale: 1,
            })

            //document.getElementById('direction_vector').innerHTML = "["+direction+"]";
            add_to_console("Done",'green');
        }
    }
}

// DEPENDENCY GRAPH
function make_dependency_graph() {
    add_to_console("Running simulation with option: depdency graph...",'#c7c7c7');
    option = 2;

    // REFRESH ...

    iterators = new Map();
    reads = new Map();
    writes = new Map();
    reads_it = new Map();
    writes_it = new Map();
    current_stmt = 0;
    variables_in_array = new Array();
    variables_in_iterator = new Array();
    iterations_1 = new Array();
    iterations_2 = new Array();
    stop_the_program = false;
    clean = false;
    known_vars = new Map();
    lhs_incorrect = false;

    raw = new Array();
    war = new Array();
    waw = new Array();
    raw_it = new Array();
    war_it = new Array();
    waw_it = new Array();
    raw_map = new Map();
    war_map = new Map();
    waw_map = new Map();

    // HELP
    var cnt = 1;
    var graph_links = new Map();
    var multi = new Map();
    var deepness = 0;
    var max_deepness = 0;
    var edges_added = new Map();
    height = 529;


    run_simulation(ast);
    if (lhs_incorrect == true) {
        add_to_console("ERROR [Incorrect assignment]. Assign to variables or arrays",'orange');
    }
    else if (variables_in_iterator.length > 0) {
        add_to_console("ERROR [Unknown variable in iterator: "+variables_in_iterator[0]+"]. Use constants or other iterators",'orange');
    }
    else if (variables_in_array.length > 0) {
        add_to_console("ERROR [Unknown variable in array call: "+variables_in_array[0]+"]. Use constants or iterators",'orange');
    }
    else {
        add_to_console("Simulation done",'green');

        // GRAPH DECL
        // create an array with nodes
        var nodes = new vis.DataSet([]);

        // create an array with edges
        var edges = new vis.DataSet([]);

        // create a network
        var container = document.getElementById('dg_network');

        // provide the data in the vis format
        var data = {
            nodes: nodes,
            edges: edges
        };

        //nodes.on('*', function (event, properties, senderId) {});

        var width = window.innerWidth - 650 - 15;

        add_to_console("Building dependency graph...");
        for (i = 1; i <= ast.stmt_nr; i++) {
            if (stmt_register.length == 0 || stmt_register.has(i)) {
                nodes.add({id: i, label: "S"+i.toString()});
            }
        }

        for (i = 0; i < raw.length; i++) {
            if (edges_added.has(raw[i][0]+","+raw[i][1])) {
                var new_delta = edges_added.get(raw[i][0]+","+raw[i][1])+","+get_delta(raw[i][2],'raw');
                edges.update({id: raw[i][0]+","+raw[i][1], from: raw[i][0], to: raw[i][1], label: new_delta});
                edges_added.set(raw[i][0]+","+raw[i][1],new_delta);
            }
            else {
                var new_delta = get_delta(raw[i][2],'raw');
                edges.add({id: raw[i][0]+","+raw[i][1], from: raw[i][0], to: raw[i][1], label: new_delta });
                edges_added.set(raw[i][0]+","+raw[i][1],new_delta);
            }
        }

        for (i = 0; i < war.length; i++) {
            if (edges_added.has(war[i][0]+","+war[i][1])) {
                var new_delta = edges_added.get(war[i][0]+","+war[i][1])+","+get_delta(war[i][2],'war');
                edges.update({id: war[i][0]+","+war[i][1], from: war[i][0], to: war[i][1], label: new_delta});
                edges_added.set(war[i][0]+","+war[i][1],new_delta);
            }
            else {
                var new_delta = get_delta(war[i][2],'war');
                edges.add({id: war[i][0]+","+war[i][1], from: war[i][0], to: war[i][1], label: new_delta });
                edges_added.set(war[i][0]+","+war[i][1],new_delta);
            }
        }

        for (i = 0; i < waw.length; i++) {
            if (edges_added.has(waw[i][0]+","+waw[i][1])) {
                var new_delta = edges_added.get(waw[i][0]+","+waw[i][1])+","+get_delta(waw[i][2],'waw');
                edges.update({id: waw[i][0]+","+waw[i][1], from: waw[i][0], to: waw[i][1], label: new_delta});
                edges_added.set(waw[i][0]+","+waw[i][1],new_delta);
            }
            else {
                var new_delta = get_delta(waw[i][2],'waw');
                edges.add({id: waw[i][0]+","+waw[i][1], from: waw[i][0], to: waw[i][1], label: new_delta });
                edges_added.set(waw[i][0]+","+waw[i][1],new_delta);
            }
        }

        var options = {
            width: width+'px',
            height: height+'px',
            nodes: {
                font: {face: 'Arvo', color: 'white', size: 30},
                color: {
                    background: '#888',
                    highlight: 'blue',
                },
                margin:10,
                shape: 'circle',
                borderWidth: 0,
            },
            edges: {
                font: {face: 'Arvo', color: '#444', size: 25},
                smooth: {
                    type: 'curvedCW',
                    forceDirection: 'none'
                },
                arrows: {
                    to: {
                        enabled: true
                    }
                },
                color: {
                    color: '#666',
                    highlight: 'red'
                }
            },
            physics: true,
            interaction: {
                dragNodes: true,
                zoomView: true,
                dragView: true
            }
            };

        network = new vis.Network(container, data, options);

        add_to_console("Done",'green');
    }
}

// Subscript classes and functions

class Subscript {
    constructor() {
        this.elems = new Array();
        this.vars = new Set();
    }
    add(single_sub) {
        this.elems.push(single_sub);
        this.vars = this.vars.union(single_sub.vars);
    }
    put_index(index) {
        this.index = index;
    }
}

class SingleSub {
    constructor(expr,str) {
        this.expr = expr;
        this.str = str;
        this.vars = get_vars_in(expr);
    }
}

class Partition {
    constructor(subscript) {
        this.subscripts = new Array(subscript);
        this.vars = subscript.vars;
    }
    add(partition) {
        for (var i = 0; i < partition.subscripts.length; i ++) {
            this.subscripts.push(partition.subscripts[i]);
        }
        this.vars = this.vars.union(partition.vars);
    }
    classify(its) {
        if (this.subscripts.length > 1) return "coupled";
        else {
            var subscript = this.subscripts[0];
            var cnt = 0;
            for (var i = 0; i < its.length; i++) {
                if (subscript.vars.has(its[i])) cnt ++;
            }
            if (cnt == 0) return "ziv";
            else if (cnt == 1) return "siv";
            else return "miv";
        }
    }
}

function make_subscripts (list) {
    var subscripts = new Array();
    for (var i = 0; i < list[0].index_list.length; i ++) {
        var subscript = new Subscript();
        for (var j = 0; j < list.length; j ++) {
            subscript.add(new SingleSub(list[j].index_list[i],list[j].index_text[i]));
        }
        subscript.put_index(i);
        subscripts.push(subscript);
    } 
    return subscripts;
}

function get_vars_in (expr) {
    if (expr.type == 'var') {
        return new Set([expr.variable]);
    }
    else if (expr.type == 'op') {
        if (expr.lhs == null) {
            return get_vars_in(expr.rhs);
        }
        else {
            return get_vars_in(expr.rhs).union(get_vars_in(expr.lhs));
        }
    }
    return new Set();
}

function get_selected_arrs() {
    var i;
    var arrs = new Array();
    var wrs = writes_selected.entriesArray();
    var rds = reads_selected.entriesArray();
    for (i = 0; i < wrs.length; i ++) {
        arrs.push(writes_enum.get(wrs[i][0]));
    }
    for (i = 0; i < rds.length; i ++) {
        arrs.push(reads_enum.get(rds[i][0]));
    }
    return arrs;
}

function check_all(arr_list) { // id, dimension, iterators at, and returns iterators
    if (arr_list.length == 0) return -1;
    var i;
    var id = arr_list[0].id;
    var dimension = arr_list[0].index_list.length;
    var iterators_at = arr_list[0].iterators_at.toString();
    for (i = 1; i < arr_list.length; i++) {
        if (arr_list[i].id != id) return -2;
        if (arr_list[i].index_list.length != dimension ) return -3;
        if (arr_list[i].iterators_at.toString() != iterators_at) return -4;
    }
    var its = new Array();
    for (i = 0; i < arr_list[0].iterators_at.length; i++) {
        its.push(arr_list[0].iterators_at[i][0]);
    }
    return its;
}

function subscript_partition(subscripts,its) {
    var i, j, k;
    var partitions = new Array();
    for (i = 0; i < subscripts.length; i ++) {
        partitions.push(new Partition(subscripts[i]));
    }
    for (i = 0; i < its.length; i ++) {
        var k = -1;
        for (j = 0; j < partitions.length; j ++) {
            if (partitions[j].vars.has(its[i])) {
                if (k == -1) k = j;
                else {
                    partitions[k].add(partitions[j]);
                    partitions.splice(j,1);
                }
            }
        }
    }
    return partitions;
}

// GLOBALS FOR SUBSCRIPT TESTS

var arrs;
var its;
var subscripts;
var partitions;
var id = 0;

document.getElementById("refresh").addEventListener('click', function(event) {
    document.getElementById('arrs').innerHTML = "";
    document.getElementById('subscripts').innerHTML = "";
    document.getElementById('partitions').innerHTML = "";
    document.getElementById('st_step_select').style = "opacity:1";
    document.getElementById("st_select").style = "display:block;";
    document.getElementById("st_partition").style = "display:block;";
    document.getElementById('st_step_part').style = "display:none; opacity:1";
    document.getElementById('st_step_classify').style ="display:none; opacity:1";
    id = 0;
});

document.getElementById("st_select").addEventListener('click', function(event) {
    var i , j ;

    arrs = get_selected_arrs();
    its = check_all(arrs);
    subscripts = make_subscripts(arrs);

    document.getElementById("st_select").style = "display:none;";
    document.getElementById("st_step_part").style = "display:block";
    document.getElementById("st_step_select").style = "opacity:0.4";

    var subscripts_div = document.getElementById("subscripts");

    for (i = 0; i < subscripts.length; i ++) {
        var text_form = "&lt;";
        for (j = 0; j < subscripts[i].elems.length; j ++) {
            text_form += subscripts[i].elems[j].str + ",";
        }
        text_form = text_form.substring(0,text_form.length-1) + "&gt";

        var subscript = document.createElement('div');
        subscript.className = "subscript";
        subscript.innerHTML = '<span class="subscript_nr">'+subscripts[i].index+'</span><span class="actual_subscript">'+text_form+'</span>';
        subscripts_div.appendChild(subscript);
    }

    var text = "";
    for (i = 0; i < arrs.length; i ++) {
        text += '<span class = "arr">'+arrs[i].id+'[';
        for (j = 0; j < arrs[i].index_text.length; j ++) {
            text += arrs[i].index_text[j] + ",";
        }
        text = text.substring(0,text.length-1) + ']</span>';
    }

    document.getElementById("arrs").innerHTML = text;
});

document.getElementById("st_partition").addEventListener('click', function(event) {
    document.getElementById("st_partition").style = "display:none";
    document.getElementById("st_step_classify").style = "display:block";
    document.getElementById("st_step_part").style = "opacity:0.4";
    
    partitions = subscript_partition(subscripts,its);

    var partitions_div = document.getElementById('partitions');
    for (var i = 0; i < partitions.length; i ++) {
        text_form = "{";
        for (var j = 0; j < partitions[i].subscripts.length; j ++) {
            text_form += '<div class="subscript"><span class="subscript_nr">'+partitions[i].subscripts[j].index+'</span><span class="actual_subscript">';
            text_form += "&lt;";
            var forms = new Array();
            for (var k = 0; k < partitions[i].subscripts[j].elems.length; k ++) {
                text_form += partitions[i].subscripts[j].elems[k].str + ",";
                var arrs = new Array();
                forms.push(get_form(partitions[i].subscripts[j].elems[k].expr));
            }
            text_form = text_form.substring(0,text_form.length-1) + "&gt";
            text_form += '</span></div>,';
        }
        text_form = text_form.substring(0,text_form.length-1) + "}";
        var partition = document.createElement('div');
        partition.className = "partition";
        partition.innerHTML = '<div class="actual_partition">'+text_form+'</div><div class="classification">'+partitions[i].classify(its)+'</div>';
        if (partitions[i].classify(its) == 'siv') {
            partition.innerHTML += '<div class="classification">'+siv_form(forms)+'</div>';
        }
        partitions_div.appendChild(partition);
    }
});

// Subscript form

function Value(value) {
    this.type = 'val';
    this.value = value;
}

function Variable(variable) {
    this.type = 'var';
    this.variable = variable;
}

function get_form(expr) {
    if (expr.type == 'var') {
        var variable = new Variable(expr.variable);
        variable.elems = new Array();
        variable.elems.push(new Value(1));
        var arr = new Array();
        arr.push(variable);
        return arr;
    }
    else if (expr.type == 'val') {
        var arr = new Array();
        arr.push(new Value(expr.val));
        return arr;
    }
    else if (expr.type == 'op') {
        var arr = new Array();
        arr.push(new Value(-1));
        if (expr.lhs == null) {
            if (expr.op == '-') return get_form_mult(get_form(expr.rhs),arr);
            else return get_form(expr.rhs);
        }
        else {
            if (expr.op == '+') return get_form_add(get_form(expr.lhs),get_form(expr.rhs));
            else if (expr.op == '-') return get_form_add(get_form(expr.lhs),get_form_mult(get_form(expr.rhs),arr));
            else if (expr.op == '*') return get_form_mult(get_form(expr.lhs),get_form(expr.rhs));
        }
    }
    return "not supported";
}

/*
function F_Set(val) {
    this.vars = new Array();
    this.val = val;
}

function F_Var(variable) {
    this.coef_val = 1;
    this.coef_vars = new Array();
    this.variable = variable;
}*/

/*function get_form(expr) {
    if (expr.type == 'var') {
        var set = new F_Set(0);
        set.vars.push(new F_Var(expr.variable));
        return set;
    }
    if (expr.type == 'val') return new F_Set(expr.val);
    if (expr.type == 'op') {
        if (expr.lhs == null) {
            if (expr.op == '-') return get_form_mult(get_form(expr.rhs),new F_Set(-1));
        }
        else {
            if (expr.op == '+') return get_form_add(get_form(expr.lhs),get_form(expr.rhs));
            else if (expr.op == '-') return get_form_add(get_form(expr.lhs),get_form_mult(get_form(expr.rhs),new F_Set(-1)));
            else if (expr.op == '*') return get_form_mult(get_form(expr.lhs),get_form(expr.rhs));
        }
    }
}*/

function get_form_mult(x,y) {
    var i, j, ii, ok;
    var z = new Array();
    var k = new Map();
    for (i = 0; i < x.length; i ++) {
        for (j = 0; j < y.length; j ++) {
            if (k.has(i+","+j)) {
                if (j < y.length-1) j++;
                else break;
            }
            else {
                k.set(i+","+j,true);
                k.set(j+","+i,true);
            }
            if (x[i].type == 'var' && y[j].type == 'var') {
                if (x[i].variable == y[j].variable) return "not supported";
                else if (its.has(y[j].variable)) {
                    z.push(new Variable(y[j].variable));
                    var h = new Array();
                    h.push(x[i]);
                    z[z.length-1].elems = get_form_mult(y[j].elems,h);
                }
                else {
                    z.push(new Variable(x[i].variable));
                    var h = new Array();
                    h.push(y[i]);
                    z[z.length-1].elems = get_form_mult(x[i].elems,h);
                }
            }
            else {
                if (x[i].type == 'var') {
                    var h = new Array();
                    h.push(y[j]);
                    ok = 0;
                    for (ii = 0; ii < z.length; ii ++) {
                        if (z[ii].type == 'var') {
                            if (z[ii].variable == x[i].variable) {
                                z[ii].elems = get_form_add(z[ii].elems,get_form_mult(x[i].elems,h));
                                ok = 1;
                            }
                        }
                    }
                    if (ok == 0) {
                        z.push(x[i]);
                        z[z.length-1].elems = get_form_mult(x[i].elems,h);
                    }
                }
                else if (y[j].type == 'var') {
                    var h = new Array();
                    h.push(x[i]);
                    ok = 0;
                    for (ii = 0; ii < z.length; ii ++) {
                        if (z[ii].type == 'var') {
                            if (z[ii].variable == y[j].variable) {
                                z[ii].elems = get_form_add(z[ii].elems,get_form_mult(y[j].elems,h));
                                ok = 1;
                            }
                        }
                    }
                    if (ok == 0) {
                        z.push(y[j]);
                        z[z.length-1].elems = get_form_mult(y[j].elems,h);
                    }
                }
                else {
                    z.push(new Value(x[i].value*y[j].value));
                }
            }
        }
    }
    return z;
}

function get_form_add(x,y) {
    var i, j;
    var z = new Array();
    var w = new Array();
    for (j = 0 ; j < y.length; j ++) {
        z.push(0);
    }
    for (i = 0; i < x.length; i ++) {
        w.push(x[i]);
        for (j = 0; j < y.length; j ++) {
            if (x[i].type == 'var' && y[j].type == 'var'){
                if (x[i].variable == y[j].variable) {
                    w[i].elems = get_form_add(x[i].elems,y[j].elems);
                    z[j] = 1;
                }
            }
            else if (x[i].type == 'val' && y[j].type == 'val') {
                w[i].value = x[i].value + y[j].value;
                z[j] = 1;
            }
        }
    }
    for (j = 0; j < y.length; j ++) {
        if (z[j] == 0) w.push(y[j]);
    }
    return w;
}

/*
function get_form_add(x,y) {
    var i, j;
    for (i = 0; i < x.vars.length; i ++) {
        for (j = 0; j < y.vars.length; j ++) {
            if (x.vars[i].variable == y.vars[j].variable) {
                x.vars[i].coef_val += y.vars[j].coef_val;
                //x.vars[i].coef_vars.push(y.vars[j].coef_vars);
                y.vars.splice(j,1);
            }
        }
    }
    for (j = 0; j < y.vars.length; j ++) {
        x.vars.push(y.vars[j]);
    }
    x.val += y.val;
    return x;
}

function get_form_mult(x,y) {
    var i, j;
    for (i = 0; i < x.vars.length; i++) {
        x.vars[i].coef_val *= y.val;
        for (j = 0; j < y.vars.length; j++) {
            if (x.vars[i].variable == y.vars[j].variable) {
                return "not_supported";
            }
            else if (its.has(x.vars[i].variable) && its.has(y.vars[j].variable)) {
                return "not_supported";
            }
            else if (its.has(x.vars[i].variable)) {
                x.vars[i].coef_val *= y.vars[j].coef_val;
                x.vars[i].coef_vars.push(y.vars[j].variable);
            }
            else if (its.has(y.vars[j].variable)) {
                x.vars[i].coef_val *= y.vars[j].coef_val;
                x.vars[i].coef_vars.push(x.vars[i].variable);
                x.vars[i].variable = y.vars[j].variable;
            }
            else {
                return "not_supported";
            }
        }
    }
    for (j = 0; j < y.vars.length; j++) {
        y.vars[j].coef_val *= x.val;
        if (y.vars[j].coef_val != 0 ) x.vars.push(y.vars[j]);
    }
    x.val *= y.val;
    return x;
}*/

function siv_form(forms) {
    if (forms.length >= 2) {
        var x = forms[0];
        var y = forms[1];
        return siv_equiv(x,y)
    }
    return null;
}

function siv_equiv(x,y) {
    var new_x = new Array();
    var new_y = new Array();
    var times_x = null;
    var times_y = null;
    for (i = 0; i < x.length; i ++) {
        if (x[i].type == 'var') {
            if (its.has(x[i].variable)) {
                times_x = x[i].elems;
            }
            else {
                new_x.push(x[i]);
            }
        }
        else {
            new_x.push(x[i]);
        }
    }
    for (i = 0; i < y.length; i ++) {
        if (y[i].type == 'var') {
            if (its.has(y[i].variable)) {
                times_y = y[i].elems;
            }
            else {
                new_y.push(y[i]);
            }
        }
        else {
            new_y.push(y[i]);
        }
    }
    if (times_x == null || times_y == null) return 'weak-zero';
    if (const_equiv(times_x,times_y)) return 'strong';
    var arr = new Array();
    arr.push(new Value(-1));
    if (const_equiv(times_x,get_form_mult(times_y,arr))) return 'weak-crossing'
    else return 'weak';
}

function const_equiv(x,y) {
    var i, j;
    for (i = 0; i < x.length; i ++) {
        match = false;
        for (j = 0; j < y.length; j ++) {
            if (x[i].type == 'val' && y[i].type == 'val'){
                if (x[i].value == y[i].value) match = true;
            }
            else if (x[i].type == 'var' && y[i].type == 'var'){
                if (x[i].variable == y[i].variable) {
                    if (const_equiv(x[i].elems,y[i].elems)) match = true;
                }
            }
        }
        if (!match) {
            return false;
        }
    }
    return true;
}


// Subscript end




// GCD Globals

function gcd (a, b) {
    if ( ! b) {
        return a;
    }

    return gcd(b, a % b);
}

function gcd_test(x,y) {
    var X;
    var Y;
    if (x.id != y.id) {
        document.getElementById("gcd_status").innerHTML = "The arrays of the calls do not match. There are is no dependency.";
    }
    else if (x.index_list.length != y.index_list.length) {
        document.getElementById("gcd_status").innerHTML = "The dimensions of the arrays called do not match !?";
    }
    else {
        for (var i = 0; i < x.index_list.length; i ++) {
            X = gcd_extract(x.index_list[i]);
            Y = gcd_extract(y.index_list[i]);
            console.log(X+"..."+Y);
            var divider = gcd(X[1],Y[1]);
            var divided = Y[2]-X[2];
            console.log(divider,divided);
            var res = divided%divider;
            console.log(res);
            if (divider == 1) {
                document.getElementById("gcd_status").innerHTML = "GCD is 1 which divides everything.";
            }
            else {
                if (res == 0) {
                    document.getElementById("gcd_status").innerHTML = "The GCD is "+divider+", which divides "+divided+" => there is a dependency.";
                }
                else {
                    document.getElementById("gcd_status").innerHTML = "The GCD is "+divider+", which does not divide "+divided+" => there is no dependency.";
                }
            }
        }
    }
}

function gcd_extract(x) { // returns [x,2,-3] for A[2*x-3]
    var type = x.type;
    var op = x.op;
    var lhs = x.lhs;
    var rhs = x.rhs;

    if (type == 'val') {
        return [null,1,x.val];
    }
    else if (type == 'var') {
        return [x.variable,1,0];
    }
    else if (type == 'op')
    {   
        if (lhs == null) {
            var crhs = gcd_extract(rhs);
            if (op == '-') return [crhs[0],-crhs[1],-chrs[2]];
            else if (op == '+') return crhs;
        }
        else {
            var clhs = gcd_extract(lhs);
            var crhs = gcd_extract(rhs);
            if (clhs[0] == crhs[0]) {
                if (clhs[0] == null) {
                    if (op == '+') return [null,1,clhs[2]+crhs[2]];
                    else if (op == '-') return [null,1,clhs[2]-crhs[2]];
                    else if (op == '*') return [null,1,clhs[2]*crhs[2]];
                    else if (op == '/') return [null,1,clhs[2]/crhs[2]];
                }
                else {
                    if (op == '+') return [clhs[0],clhs[1]+crhs[1],clhs[2]+crhs[2]];
                    else if (op == '-') return [clhs[0],clhs[1]-crhs[2],clhs[2]-crhs[2]];
                }
            }
            else if (clhs[0] != null && crhs[0] == null) {
                if (op == '+') return [clhs[0],clhs[1],clhs[2]+crhs[2]];
                else if (op == '-') return [clhs[0],clhs[1],clhs[2]-crhs[2]];
                else if (op == '*') return [clhs[0],clhs[1]*crhs[2],clhs[2]*crhs[2]];
                else if (op == '/') return [clhs[0],clhs[1]/crhs[2],clhs[2]/crhs[2]];
            }
            else if (clhs[0] == null && crhs[0] != null) {
                if (op == '+') return [crhs[0],crhs[1],clhs[2]+crhs[2]];
                else if (op == '-') return [crhs[0],-crhs[1],clhs[2]-crhs[2]];
                else if (op == '*') return [crhs[0],clhs[2]*crhs[1],clhs[2]*crhs[2]];
            }
        }
    }
}

function run_active() {
    var i, j, tabcontent;

    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        if (tabcontent[i].style.display == "block") {
            if (i == 0) {
                var arr = writes_selected.entriesArray();
                for (j = 0; j < arr.length; j++) {
                    document.getElementById("vwrite_"+arr[j][0]).click();
                }
                arr = reads_selected.entriesArray();
                for (j = 0; j < arr.length; j++) {
                    document.getElementById("vread_"+arr[j][0]).click();
                }
                make_iteration_space();
                selection_mode = false;
            }
            else if (i == 1) {
                var arr = writes_selected.entriesArray();
                for (j = 0; j < arr.length; j++) {
                    document.getElementById("vwrite_"+arr[j][0]).click();
                }
                arr = reads_selected.entriesArray();
                for (j = 0; j < arr.length; j++) {
                    document.getElementById("vread_"+arr[j][0]).click();
                }
                make_dependency_graph();
                selection_mode = false;
                wrs = new Map();
            }
            else if (i == 2) {
                selection_mode = true;
            }
        }
    }
    change = false;
}

document.getElementById("run_button").addEventListener('click', function(event) {
    run_active();
});

/*document.getElementById("gcd_button").addEventListener('click', function(event) {
    var x;
    var y;
    if (wrs.length != 2) {
        document.getElementById("sub_status").innerHTML = "Have two calls selected to run the GCD Test.";
    }
    else {
        var x_type = wrs.get(1).substring(0,1);
        var y_type = wrs.get(2).substring(0,1);
        if (x_type == 'r' && y_type == 'r') {
            document.getElementById("gcd_status").innerHTML = "The selected calls are both reads. There cannot be a dependency between 2 reads.";
        }
        else {
            var x_no = parseInt(wrs.get(1).substring(1,wrs.get(1).length));
            var y_no = parseInt(wrs.get(2).substring(1,wrs.get(2).length));
            if (x_type == 'w') x = writes_enum.get(x_no);
            else if (x_type == 'r') x = reads_enum.get(x_no);
            if (y_type == 'w') y = writes_enum.get(y_no);
            else if (y_type == 'r') y = reads_enum.get(y_no);
            gcd_test(x,y);
        }
    }
});*/

$('#run_button').qtip({
    content: {
        text: 'Runs the type of analysis selected on the right hand side'
    }
});
$('#toggle_thing').qtip({
    content: {
        text: 'Toggle on/off: runs whenever there is a change in the selection of statements/writes/reads. <br><br>Consider turning off when writing programs with more than 2 nested loops'
    }
});

/*$('#question_vis').qtip({
    content: {
        text: $(this).next('.tooltip_vis')
    }
});*/

// Create the tooltips only when document ready
$(document).ready(function()
 {
     // MAKE SURE YOUR SELECTOR MATCHES SOMETHING IN YOUR HTML!!!
     $('#question_vis').each(function() {
         $(this).qtip({
             content: {
                 text: $(this).next('#tooltip_vis')
             },
             style: { classes: 'qtip-bootstrap' }
         });
     });
 });




    
</script>
    
</body>
</html>