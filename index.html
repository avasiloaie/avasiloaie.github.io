
<!DOCTYPE html>
<html>

<link rel="stylesheet" href="style.css">
    
<!-- FONTS -->
<link href="https://fonts.googleapis.com/css?family=Arvo:400,400i,700,700i" rel="stylesheet">
    
<!-- USER INPUT -->
<link rel="stylesheet" href="lib/codemirror.css">
<link rel="stylesheet" href="webfont.css">
<script src="lib/codemirror.js"></script>
<script src="collections.min.js"></script>
    
<!-- DEPENDENCY ANALYSIS -->
<script src="bundle.js"></script>
<script>
function load_test(nr) {
    var test = [];
    test[1] = `DO I=1,4
	DO J=1,5
    	A(I,J)=A(I,J-1)
    ENDDO
ENDDO
`;
    test[2] = `DO I=1,4
	DO J=1,4
    	A(I,J)=A(I,J+1)
    ENDDO
ENDDO
`;
    test[3] = `DO I=1,3
	DO J=1,3
    	A(I,1)=A(I+10,J+10)
    ENDDO
ENDDO
`;
    test[4] = `DO I=1,5
	DO J=1,5
    	A(I,J)=A(I-1,J-1)+10
    ENDDO
ENDDO
`;
    test[5] = `DO I=1,3
	DO J=1,3
    	A(I,J)=A(2,2)
    ENDDO
ENDDO
`;
    test[6] = `DO I=1,3
	DO J=1,3
    	A(I,J)=A(J,I)
    ENDDO
ENDDO
`;
    test[7] = `DO I=1,3
	DO J=1,3
    	A(I-1,J-1)=A(I,J)
    	A(I,J)=A(I,J-1)
    ENDDO
ENDDO
`;
    test[8] = `DO I=1,5
	DO J=1,5
    	A(I,J-1)=A(I,J)
        A(I,J)=A(I-1,J-1)
    ENDDO
ENDDO
`;
    test[9] = `DO i = 1,100
	x(i) = y(i) + 10
	DO j = 1,100
		b(j) = a(j,n)
		DO k = 1,100
 			a(j+1,k) = b(j)+c(j,k)
		ENDDO
		y(i+j) = a(j+1,n)
	ENDDO
ENDDO
`;
    $editor.setValue(test[nr]);
}
</script>
    
<!-- GRAPH RENDERING -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css">

<!-- CHROMA -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.2/jquery.min.js"></script>
<script>

var colors = new Array(
  //[62,35,255],
  //[60,255,60],
  //[255,35,98],
  //[45,175,230],
  //[255,0,255],
  //[255,128,0]
  [255,108,28],
  [232,54,48],
  [255,52,178],
  [255,170,38]);

var step = 0;
//color table indices for: 
// current color left
// next color left
// current color right
// next color right
var colorIndices = [0,1,2,3];

//transition speed
var gradientSpeed = 0.0003;

function updateGradient()
{
  
  if ( $===undefined ) return;
  
var c0_0 = colors[colorIndices[0]];
var c0_1 = colors[colorIndices[1]];
var c1_0 = colors[colorIndices[2]];
var c1_1 = colors[colorIndices[3]];

var istep = 1 - step;
var r1 = Math.round(istep * c0_0[0] + step * c0_1[0]);
var g1 = Math.round(istep * c0_0[1] + step * c0_1[1]);
var b1 = Math.round(istep * c0_0[2] + step * c0_1[2]);
var color1 = "rgb("+r1+","+g1+","+b1+")";

var r2 = Math.round(istep * c1_0[0] + step * c1_1[0]);
var g2 = Math.round(istep * c1_0[1] + step * c1_1[1]);
var b2 = Math.round(istep * c1_0[2] + step * c1_1[2]);
var color2 = "rgb("+r2+","+g2+","+b2+")";

 $('#header').css({
   background: "-webkit-gradient(linear, left top, right top, from("+color1+"), to("+color2+"))"}).css({
    background: "-moz-linear-gradient(left, "+color1+" 0%, "+color2+" 100%)"});
  
  step += gradientSpeed;
  if ( step >= 1 )
  {
    step %= 1;
    colorIndices[0] = colorIndices[1];
    colorIndices[2] = colorIndices[3];
    
    //pick two new target color indices
    //do not pick the same as the current one
    colorIndices[1] = ( colorIndices[1] + Math.floor( 1 + Math.random() * (colors.length - 1))) % colors.length;
    colorIndices[3] = ( colorIndices[3] + Math.floor( 1 + Math.random() * (colors.length - 1))) % colors.length;
    
  }
}

setInterval(updateGradient,10);
</script>
    
<style type="text/css">
    #mynetwork {
        width: 100%;
        height: 604px;
        border: 2px solid lightgray;
        display:inline-block;
        margin:10px 0px 10px 0;
    }
</style>
    
<body>
    
<div id="header">
    <div id="header_left">
        <div id="title">Compiler Dependency</div>
        <div id="desc">> Sandbox Tool</div>
    </div>
    <div id="header_right">
        <!--
        <ul>
            <li><a href="">Sample Page 1</a></li>
            <li><a href="">Sample Page 2</a></li>
            <li><a href="">Sample Page 3</a></li>
            <li><a href="">Sample Page 4</a></li>
        </ul>-->
    </div>
</div>
    
<div id="wrapper">
    
<div id="editor">
    <div id="code"></div>
    <div class="under_code">
    <button id="parse_button" class="my_button"><span class="my_button_icon">~</span><span class="my_button_text">Parse</span></button>
    <div id="loader" include="form-input-select()">
        <select id ="option" required>
          <!--
            This is how we can do "placeholder" options.
            note: "required" attribute is on the select
          -->
          <option value=""
                  hidden
          >Routine</option>
      
          <!-- normal options -->
          <option value="1">Iteration Space</option>
          <option value="2">Dependency Graph</option>
        </select>
    </div>
    <nav id="primary_nav_wrap">
            <ul>
              <li><a href="#">Load test</a>
                <ul>
                  <li><a href="#">Basic</a>
                    <ul>
                      <li><a href="#" onclick="load_test(1); return false;">RAW</a></li>
                      <li><a href="#" onclick="load_test(2); return false;">WAR</a></li>
                      <li><a href="#" onclick="load_test(3); return false;">WAW</a></li>
                    </ul>
                  </li>
                  <li><a href="#">Iteration Space</a>
                    <ul>
                      <li><a href="#" onclick="load_test(4); return false;">-1,-1</a></li>
                      <li><a href="#" onclick="load_test(5); return false;">One point</a></li>
                      <li><a href="#" onclick="load_test(6); return false;">A(I,J) = A(J,I)</a></li>
                      <li><a href="#" onclick="load_test(7); return false;">Multiple statements</a></li>
                    </ul>
                  </li>
                  <li><a href="#">Dependency Graph</a>
                    <ul>
                      <li><a href="#" onclick="load_test(8); return false;">Two Statements</a></li>
                      <li><a href="#" onclick="load_test(9); return false;">Slide</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
            </nav>
            
            </div>
    </div>
        
</div>
<div id="visualizer">
    <div id="root"></div>
    <div class="under_code_vis" id="vis_under">
    <button id="edit_button" class="my_button"><span class="my_button_icon">*</span><span class="my_button_text">Edit</span></button>
    </div>
</div>
    
<div id="printer">
    <div id="options_bar">
        <button id="is_button" class="button_tab">Iteration Space</button>
        <button id="dg_button" class="button_tab">Dependency Graph</button>
    </div>
    <div id="mynetwork"></div>
    <div id="labels">
        <div id="labels_itspc">
            <div style="display:inline-block; margin-right:10px; font-weight:bold;">Dependencies:</div>
            <div style="width:20px; height:20px; background-color:#FF7C23; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">RAW</div>
            <div style="margin-left:15px; width:20px; height:20px; background-color:#5889FF; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">WAR</div>
            <div style="margin-left:15px; width:20px; height:20px; background-color:red; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">WAW</div>
            <div style="margin-left:15px; width:20px; height:20px; background-color:#B660E8; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">Mixed</div>
        </div>
        <div id="labels_dpgph">
            <div style="display:inline-block; margin-right:10px; font-weight:bold;">Labels:</div>
            <div style="display: inline-block;">δ</div><div style="display:inline-block; margin-left:5px;">RAW</div>
            <div style="margin-left:15px; display: inline-block;">δ⁻¹</div><div style="display:inline-block; margin-left:5px;">WAR</div>
            <div style="margin-left:15px; display: inline-block;">δ⁰</div><div style="display:inline-block; margin-left:5px;">WAW</div>
        </div>
    </div>
</div>
<div id ="console" style="overflow-y: scroll; height:200px;"></div>
    
    
</div>
<div id="footer"></div>
    
<script type="text/javascript"> 

// EDITOR

var $editor = CodeMirror(document.getElementById('code'), {
  value: "INPUT CODE HERE...",
  mode:  "javascript",
  lineNumbers: true
});

// GLOBAL DECLS

var ast;
var tab;
var tab_size = 40;
var line_cnt;
var read_cnt;
var vwrites;
var vreads;
var stmts;
var writes_register = new Map();
var reads_register = new Map();
var stmt_register = new Map();
var visualizer = document.getElementById('visualizer');
var vis_under = document.getElementById('vis_under');
var too_deep = 0;

// CONSOLE INIT
function add_to_console(line,color) {
        var d = new Date();
        var ul = document.getElementById("console");
        var li = document.createElement("li");
        li.appendChild(document.createTextNode(d.toLocaleTimeString()+": "+line));
        li.style = "color: "+color+";";
        ul.appendChild(li);
        ul.scrollTop = ul.scrollHeight;
    }

add_to_console("App loaded","#c7c7c7");
// CONSOLE INIT END

// PARSE ACTIVATOR *** ***
document.getElementById("parse_button").addEventListener("click", function(){
    var input = $editor.getValue();
    input += '\n';

// REFRESH ...

// // ROOT
visualizer.removeChild(root);
root = document.createElement('div');
root.id = "root";
visualizer.insertBefore(root,vis_under);

// // COUNTERS

tab = 0;
line_cnt = 0;
vwrites = 0;
vreads = 0;
stmts = 0;
writes_register = new Map();
reads_register = new Map();
stmt_register = new Map();
too_deep = 0;

// PARSE 

add_to_console('Parsing...','#c7c7c7');
ast = parse_routine(input);
code_visualizer(ast); // VISUALIZATION
add_event_listeneners(); // LISTENERS
add_to_console('Parsing done','#c7c7c7');

// PARSE END



// // FUNCTIONS NEEDED FOR VISUALIZATION

function add_event_listeneners() {
    var i;
    for (i = 1; i <= vwrites; i++) {
        document.getElementById("vwrite_"+i).addEventListener("click", function() {
            var i = parseInt(this.id.substring(7,this.id.length));
            if (writes_register.has(i)) {
                writes_register.delete(i);
                this.style.background = "rgba(50, 50, 136, 0.6)";
                console.log("off");
            }
            else {
                writes_register.set(i,true);
                this.style.background = "blue";
                console.log("on");
            }
        });
    }
    for (i = 1; i <= vreads; i++) {
        document.getElementById("vread_"+i).addEventListener("click", function() {
            var i = parseInt(this.id.substring(6,this.id.length));
            if (reads_register.has(i)) {
                reads_register.delete(i);
                this.style.background = "rgba(180, 37, 37, 0.65)";
                console.log("off");
            }
            else {
                reads_register.set(i,true);
                this.style.background = "red";
                console.log("on");
            }
        });
    }
    for (i = 1; i <= stmts; i++) {
        document.getElementById("stmt_"+i).addEventListener("click", function() {
            var i = parseInt(this.id.substring(5,this.id.length));
            if (stmt_register.has(i)) {
                stmt_register.delete(i);
                this.style.background = "rgb(167, 165, 165)";
                console.log("off");
            }
            else {
                stmt_register.set(i,true);
                this.style.background = "#666";
                console.log("on");
            }
        });
    }
}

function add_tab(node) {
    node.style.marginLeft = (tab*tab_size)+"px";
}

function code_visualizer (ast) {
    for (var i = 0 ; i < ast.stmt_list.length; i ++) {
        root.appendChild(code_visualizer_stmt(ast.stmt_list[i]));
    }
}

function code_visualizer_stmt (stmt) {
    var s = document.createElement('div');
    if (stmt.type == "do") {
        s.appendChild(code_visualizer_do_top(stmt));
        tab ++;
        if (tab == 3) { too_deep = 1; }
        for (var i = 0; i < stmt.stmt_list.length; i ++) {
            s.appendChild(code_visualizer_stmt(stmt.stmt_list[i]));
        }
        tab --;
        s.appendChild(code_visualizer_do_end());
        return s;
    }
    else if (stmt.type == "assign") {
        s.id = "line_"+(++line_cnt);
        s.innerHTML = '<span class="stmt" id="stmt_'+stmt.nr+'">S'+stmt.nr+'</span> '+code_visualizer_assign(stmt);
        stmts = stmt.nr;
        add_tab(s);
    }
    return s;
}

function code_visualizer_do_top(stmt) {
    var top = document.createElement('div');
    top.id = "line_"+(++line_cnt);
    var x = document.createTextNode("DO "+stmt.it+" = "+code_visualizer_evaluate(stmt.start)+","+code_visualizer_evaluate(stmt.end));
    top.appendChild(x);
    add_tab(top);
    return top;
}

function code_visualizer_do_end() {
    var end = document.createElement('div');
    end.id = "line_"+(++line_cnt);
    end.textContent = "ENDDO";
    add_tab(end);
    return end;
}

function code_visualizer_assign(stmt) {
    return code_visualizer_evaluate(stmt.lhs,'lhs')+" = "+code_visualizer_evaluate(stmt.rhs,'rhs');
}

function code_visualizer_evaluate(expr,side) {
    if (expr.type == 'op') {
        if (expr.lhs == null) {
            return expr.op+code_visualizer_evaluate(expr.rhs,side);
        }
        else {
            return code_visualizer_evaluate(expr.lhs,side)+" "+expr.op+" "+code_visualizer_evaluate(expr.rhs,side);
        }
        return e;
    }
    else if (expr.type == 'val') {
        return expr.val;
    }
    else if (expr.type == 'var') {
        return expr.variable;
    }
    else if (expr.type == 'array') {
        var out = "";
        if (side == 'lhs') {
            out += '<span class="vwrite" id="vwrite_'+(++vwrites)+'">';
            expr.write_id = vwrites;
        }
        else if (side == 'rhs') {
            out += '<span class="vread" id="vread_'+(++vreads)+'">';
            expr.read_id = vreads;
        }
        out += expr.id+"(";
        for (var i = 0; i < expr.index_list.length; i++) {
            out += code_visualizer_evaluate_inside(expr.index_list[i]) + ",";
        }
        out = out.substring(0,out.length-1) + ")</span>";
        return out;
    }
}

function code_visualizer_evaluate_inside(expr) {
    if (expr.type == 'op') {
        if (expr.lhs == null) {
            return expr.op+code_visualizer_evaluate(expr.rhs);
        }
        else {
            return code_visualizer_evaluate(expr.lhs)+expr.op+code_visualizer_evaluate(expr.rhs);
        }
        return e;
    }
    else if (expr.type == 'val') {
        return expr.val;
    }
    else if (expr.type == 'var') {
        return expr.variable;
    }
    else if (expr.type == 'array') {
        var out = expr.id+"(";
        for (var i = 0; i < expr.index_list.length; i++) {
            out += code_visualizer_evaluate_inside(expr.index_list[i]) + ",";
        }
        out = out.substring(0,out.length-1) + ")";
        return out;
    }
}

// FUNCTIONS NEEDED FOR VISUALIZATION END



// CHANGE ENVIRONMENT 

document.getElementById('editor').style.display = "none";
visualizer.style.display = "block";
options_bar.style.display = "inline-block";
printer.style.marginTop = "-41px";

// CHANGE ENVIRONMENT END

});

document.getElementById("edit_button").addEventListener("click", function(){
    document.getElementById('editor').style.display = "block";
    visualizer.style.display = "none";
    options_bar.style.display = "none";
    printer.style.marginTop = "0px";
});




// GLOBALS FOR SIMULATION

    // SIM
    var iterators = new Map();
    var reads = new Map();
    var writes = new Map();
    var reads_it = new Map();
    var writes_it = new Map();
    var current_stmt = 0;
    var variables_in_array = new Array();
    var variables_in_iterator = new Array();
    var iterations_1 = new Array();
    var iterations_2 = new Array();
    var stop_the_program = false;
    var clean = false;
    var known_vars = new Map();
    var lhs_incorrect = false;

    // DEPS
    var raw = new Array();
    var war = new Array();
    var waw = new Array();
    var raw_it = new Array();
    var war_it = new Array();
    var waw_it = new Array();
    var raw_map = new Map();
    var war_map = new Map();
    var waw_map = new Map();

    // HELP

    var i;
    var j;
    var k;
    var h;
    var cnt = 1;
    var spacing;
    var current_x;
    var current_y;
    var width;
    var height = 604;
    var node_size;
    var graph_links = new Map();
    var multi = new Map();
    var deepness = 0;
    var max_deepness = 0;
    var edges_added = new Map();
    var network;

// GLOBALS FOR SIMULATION END


// FUNCTIONS FOR SIMULATION *** *** 

function Memory(key) {
    //this.id = id;
    //this.indices = indices;
    this.key = key;
}

function it_diff(it1, it2) {
    var result = 1;
    var smaller_size = it1.length < it2.length ? it1.length : it2.length;
    for (var i = 0; i < smaller_size; i ++) {
        if (it1[i][1] == it2[i][1]) {
            result++;
        }
        else {
            break;
        }
    }
    if (result == smaller_size + 1) {
        result = -1;
    }
    return result;
}

function evaluate(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;
    var op = expr.op;
    var lhs = expr.lhs;
    var rhs = expr.rhs;

    if ( type == "op" ) {
        if (lhs == null) {
            if (op == "-") return -evaluate(rhs);
            else if (op == "+") return evaluate(rhs);
            // else console.log("Not a valid operation: "+expr);
        }
        else {
            if (op == "+") return evaluate(lhs) + evaluate(rhs);
            else if (op == "-") return evaluate(lhs) - evaluate(rhs);
            else if (op == "*") return evaluate(lhs) * evaluate(rhs);
            else if (op == "/") return evaluate(lhs) / evaluate(rhs);
            else if (op == "%") return evaluate(lhs) % evaluate(rhs);
            else if (op == ".LT.") return evaluate(lhs) < evaluate(rhs);
            else if (op == ".LE.") return evaluate(lhs) <= evaluate(rhs);
            else if (op == ".GT.") return evaluate(lhs) > evaluate(rhs);
            else if (op == ".GE.") return evaluate(lhs) >= evaluate(rhs);
            else if (op == ".EQ.") return evaluate(lhs) == evaluate(rhs);
            else if (op == ".NE.") return evaluate(lhs) != evaluate(rhs);
            else if (op == ".OR.") return evaluate(lhs) || evaluate(rhs);
            else if (op == ".AND.") return evaluate(lhs) && evaluate(rhs);
            //else console.log("Not a valid operation: "+expr);
        }
    }
    else if ( type == "val" ) {
        return expr.val;
    }
    else if (type == "var" ) {
        if (iterators.has(expr.variable)) return iterators.get(expr.variable);
        else if (known_vars.has(expr.variable)) return known_vars.get(expr.variable);
        else {
            clean = false;
            return 0;
        }
    }
    else if (type == "array") {
        clean = false;
        if (stmt_register.length == 0 || stmt_register.has(current_stmt)) {
        if (reads_register.length + writes_register.length == 0 || reads_register.has(expr.read_id)) {
            simulate_array(expr);
        } }
        return 0;
    }
    else {
        return 0;
    }
}

function evaluate_left(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;

    if (type == "var") {
        return expr.variable;
    }
    else if (type == "array") {
        clean = false;
        if (stmt_register.length == 0 || stmt_register.has(current_stmt)) {
        if (writes_register.length + reads_register.length == 0 || writes_register.has(expr.write_id)) {
            simulate_array(expr);
        } }
        return 0;
    }
    else {
        clean = false;
        stop_the_program = true;
        lhs_incorrect = true;
    }
}

function evaluate_array(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;
    var op = expr.op;
    var lhs = expr.lhs;
    var rhs = expr.rhs;

    if ( type == "op" ) {
        if (lhs == null) {
            if (op == "-") return -evaluate_array(rhs);
            else if (op == "+") return evaluate_array(rhs);
            // else console.log("Not a valid operation: "+expr);
        }
        else {
            if (op == "+") return evaluate_array(lhs) + evaluate_array(rhs);
            else if (op == "-") return evaluate_array(lhs) - evaluate_array(rhs);
            else if (op == "*") return evaluate_array(lhs) * evaluate_array(rhs);
            else if (op == "/") return evaluate_array(lhs) / evaluate_array(rhs);
            else if (op == "%") return evaluate_array(lhs) % evaluate_array(rhs);
            //else console.log("Not a valid operation: "+expr);
        }
    }
    else if ( type == "val" ) {
        return expr.val;
    }
    else if (type == "var" ) {
        if (iterators.has(expr.variable)) return iterators.get(expr.variable);
        else if (known_vars.has(expr.variable)) return known_vars.get(expr.variable);
        else {
            clean = false;
            stop_the_program = true;
            variables_in_array.push(expr.variable);
            return 0;
        }
    }
    else if (type == "array") {
        variables_in_array.push(expr.id);
        clean = false;
        stop_the_program = true;
        return 0;
    }
    else {
        //console.log("Not a valid expr: "+expr); 
    }
}

function evaluate_iterator(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;
    var op = expr.op;
    var lhs = expr.lhs;
    var rhs = expr.rhs;

    if ( type == "op" ) {
        if (lhs == null) {
            if (op == "-") return -evaluate_iterator(rhs);
            else if (op == "+") return evaluate_iterator(rhs);
            // else console.log("Not a valid operation: "+expr);
        }
        else {
            if (op == "+") return evaluate_iterator(lhs) + evaluate_iterator(rhs);
            else if (op == "-") return evaluate_iterator(lhs) - evaluate_iterator(rhs);
            else if (op == "*") return evaluate_iterator(lhs) * evaluate_iterator(rhs);
            else if (op == "/") return evaluate_iterator(lhs) / evaluate_iterator(rhs);
            else if (op == "%") return evaluate_iterator(lhs) % evaluate_iterator(rhs);
            //else console.log("Not a valid operation: "+expr);
        }
    }
    else if ( type == "val" ) {
        return expr.val;
    }
    else if (type == "var" ) {
        if (iterators.has(expr.variable)) return iterators.get(expr.variable);
        else if (known_vars.has(expr.variable)) return known_vars.get(expr.variable);
        else {
            stop_the_program = true;
            clean = false;
            variables_in_iterator.push(expr.variable);
            return 0;
        }
    }
    else if (type == "array") {
        stop_the_program = true;
        clean = false;
        variables_in_iterator.push(expr.variable);
        return 0;
    }
    else {
        //console.log("Not a valid expr: "+expr); 
    }
}

function simulate_array(expr) {
    if (expr.type == "array") {
        var memory = get_memory(expr).key;
        if (option == 2) {
            if (side == "lhs") {
                // testing dependency
                if (writes.has(memory)) {
                    var m = writes.get(memory).entriesArray();
                    for (var i = 0; i < m.length; i ++) {
                        if (!waw_map.has([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString())) {
                            waw.push([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())]);
                            waw_map.set([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString(),1);
                        }
                        if (!waw_map.has([m[i][0],current_stmt,it_diff(iterators.entriesArray(),m[i][1])].toString())) {
                            waw.push([m[i][0],current_stmt,it_diff(iterators.entriesArray(),m[i][1])]);
                            waw_map.set([m[i][0],current_stmt,it_diff(iterators.entriesArray(),m[i][1])].toString(),1);
                        }
                    }
                }

                if (reads.has(memory)) {
                    var m = reads.get(memory).entriesArray();
                    for (var i = 0; i < m.length; i ++) {
                        if (!war_map.has([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString())) {
                            war.push([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())]);
                            war_map.set([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString(),1);
                        }
                    }
                }

                // adding write
                if (writes.has(memory)) {
                    var m = writes.get(memory);
                    if (!m.has(current_stmt)) {
                        m.set(current_stmt,iterators.entriesArray());
                    }
                }
                else {
                    var m = new Map();
                    m.set(current_stmt,iterators.entriesArray());
                    writes.set(memory,m);
                }
                reads.delete(memory);
            }
            else if (side == "rhs") {
                // testing dependency
                if (writes.has(memory)) {
                    var m = writes.get(memory).entriesArray();
                    for (var i = 0; i < m.length; i ++) {
                        if (!raw_map.has([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString())) {
                            raw.push([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())]);
                            raw_map.set([m[i][0],current_stmt,it_diff(m[i][1],iterators.entriesArray())].toString(),1);
                        }
                    }
                }

                // adding read
                if (reads.has(memory)) {
                    var m = reads.get(memory);
                    if (!m.has(current_stmt)) {
                        m.set(current_stmt,iterators.entriesArray());
                    }
                }
                else {
                    var m = new Map();
                    m.set(current_stmt,iterators.entriesArray());
                    reads.set(memory,m);
                }
            }
        }
        else {
            if (side == "lhs") {
                // testing dependency
                if (writes_it.has(memory)) {
                    var m = writes_it.get(memory);
                    waw_it.push([m,iterators.entriesArray()]);
                }

                if (reads_it.has(memory)) {
                    var m = reads_it.get(memory);
                    for (var i = 0; i < m.length; i ++) {
                        war_it.push([iterators.entriesArray(),m[i]]);
                    }
                }

                // adding write
                writes_it.set(memory,iterators.entriesArray());
                reads_it.delete(memory);
            }
            else if (side == "rhs") {
                // testing dependency
                if (writes_it.has(memory)) {
                    var m = writes_it.get(memory);
                    raw_it.push([m,iterators.entriesArray()]);
                }

                // adding read
                if (reads_it.has(memory)) {
                    var m = reads_it.get(memory);
                }
                else {
                    var m = new Array();
                    reads_it.set(memory,m);
                }
                m.push(iterators.entriesArray());
            }
        }
    }
}

function simulate_stmts(stmt_list) {
    for (var i = 0; i < stmt_list.length; i++) {
        var stmt = stmt_list[i];
        if (stmt.type == "do") {
            simulate_do(stmt);
        }
        else if (stmt.type == "assign") {
            current_stmt = stmt.nr;
            clean = true;
            var from;
            var to;
            side = "rhs";
            from = evaluate(stmt.rhs);
            if (clean) {
                side = "lhs";
                to = evaluate_left(stmt.lhs);
                if (clean) {
                    known_vars.set(to,from);
                }
            }
            else {
                side = "lhs";
                to = evaluate_left(stmt.lhs);
            }
        }
        else if (stmt.type == "if") {
            if (evaluate(stmt.expr)) {
                simulate_stmts(stmt.if_part);
            }
            else if (stmt.else_if_part != null) {
                for (i = 0; i < stmt.else_if_part.else_if_list.length; i ++) {
                    if (evaluate(stmt.else_if_part.else_if_list[i].expr)) {
                        simulate_stmts(stmt.else_if_part.else_if_list[i].stmt_list);
                        break;
                    }
                }
            }
            else if (stmt.else_part != null) {
                simulate_stmts(stmt.else_part.stmt_list);
            }
        }
    }
}

function simulate_do(do_stmt) {
    var it = do_stmt.it;
    iterators.set(it,evaluate_iterator(do_stmt.start));
    var step;
    if (do_stmt.step == null) step = 1;
    else { step = evaluate_iterator(do_stmt.step); }
    deepness++;
    //if (deepness > 2 && option == 1) {  too_deep = 1; }
    if (!stop_the_program) { 

    if (iterators.get(it) > evaluate_iterator(do_stmt.end) && too_deep == 0) {
        if (step > 0) { step = -step; }

        while (iterators.get(it) >= evaluate_iterator(do_stmt.end) ) {
            if (option == 1) {
                if (deepness == 1) {
                    iterations_1.push(iterators.entriesArray());
                }
                else {
                    iterations_2.push(iterators.entriesArray());
                }
            }
            simulate_stmts(do_stmt.stmt_list);
            var next_step = iterators.get(it)+step;
            iterators.set(it,next_step);
        }
    }
    else {
        while (iterators.get(it) <= evaluate_iterator(do_stmt.end) ) {
            if (option == 1) {
                if (deepness == 1) {
                    iterations_1.push(iterators.entriesArray());
                }
                else {
                    iterations_2.push(iterators.entriesArray());
                }
            }
            simulate_stmts(do_stmt.stmt_list);
            var next_step = iterators.get(it)+step;
            iterators.set(it,next_step);
        }
    }
    }
    deepness--;
    iterators.delete(it);
}

function get_memory(array_call) { // eg A(i,j) with i = 5, j = 2 -> MEM(A:5,2)
    var id = array_call.id;
    var indices = [];
    var key = "";

    var key = id + ":";

    for (var i = 0; i < array_call.index_list.length; i++) {
        current_index = evaluate_array(array_call.index_list[i],true);
        indices.push(current_index);
        key += current_index + ",";
    }

    key = key.substring(0,key.length-1);

    return new Memory(key);
}

function run_simulation(ast) {
    simulate_stmts(ast.stmt_list);
}

function calculate_graph_point() {
    var node_itself = [];
    var distance_in_between = [];
    var diff;
    if (max_deepness == 1) {
        diff = iterations_1.length-1;
        space_per_node = Math.floor((width*0.9)/(diff+1));
        node_itself[0] = Math.ceil(space_per_node*0.7);
        distance_in_between[0] = Math.floor(space_per_node*0.3);
        return [node_itself[0],distance_in_between[0]];
    }
    else if (max_deepness == 2) {
        diff = iterations_1.length-1;
        space_per_node = Math.floor((height*0.9)/(diff+1));
        node_itself[0] = Math.ceil(space_per_node*0.4);
        distance_in_between[0] = Math.floor(space_per_node*0.6);
        diff = (iterations_2.length/iterations_1.length)-1;
        space_per_node = Math.floor((width*0.9)/(diff+1));
        node_itself[1] = Math.ceil(space_per_node*0.7);
        distance_in_between[1] = Math.floor(space_per_node*0.3);
        return [node_itself,distance_in_between];
    }   
    return null;
}

function get_distance(dep) {
    var arr = new Array();
    var from = dep[0];
    var to = dep[1];
    if (from.length < to.length) {
        for (var i = 0; i < from.length; i++) {
            arr.push(to[i][1]-from[i][1]);
        }
        return arr;
    }
    else {
        for (var i = 0; i < to.length; i ++) {
            arr.push(to[i][1]-from[i][1]);
        }
        return arr;
    }
}

function get_direction(dist) {
    for (var i = 0; i < dist.length; i++) {
        if (dist[i] > 0) dist[i] = '<';
        else if (dist[i] < 0) dist[i] = '>';
        else dist[i] = '=';
    }
    return dist;
}

function get_delta(dep,type) {
    var build = "δ";
    if (type == 'war') {
        build = build + "⁻¹";
    }
    else if (type == 'waw') {
        build = build + "⁰";
    }
    if (dep == -1) {
        build = build + "∞";
    }
    else {
        var sub;
        if (dep == 1) {
            sub = '₁';
        }
        else if (dep == 2) {
            sub = '₂';
        }
        else if (dep == 3) {
            sub = '₃';
        }
        else if (dep == 4) {
            sub = '₄';
        }
        else if (dep == 5) {
            sub = '₅';
        }
        else if (dep == 6) {
            sub = '₆';
        }
        else if (dep == 7) {
            sub = '₇';
        }
        else if (dep == 8) {                           
            sub = '₈';
        }
        else if (dep == 9) {
            sub = '₉';
        }

        build = build + sub;
    }
    return build;
}

/// FUNCTIONS FOR SIMULATION END *** ***



/// SIMULATION

// ITERATION SPACE
document.getElementById("is_button").addEventListener("click", function(){
    add_to_console("Running simulation with option: iteration space...",'#c7c7c7');
    option = 1;

    // REFRESH ...

    iterators = new Map();
    reads = new Map();
    writes = new Map();
    reads_it = new Map();
    writes_it = new Map();
    current_stmt = 0;
    variables_in_array = new Array();
    variables_in_iterator = new Array();
    iterations_1 = new Array();
    iterations_2 = new Array();
    stop_the_program = false;
    clean = false;
    known_vars = new Map();
    lhs_incorrect = false;

    raw = new Array();
    war = new Array();
    waw = new Array();
    raw_it = new Array();
    war_it = new Array();
    waw_it = new Array();
    raw_map = new Map();
    war_map = new Map();
    waw_map = new Map();

    // HELP
    cnt = 1;
    graph_links = new Map();
    multi = new Map();
    deepness = 0;
    max_deepness = 0;
    edges_added = new Map();

    if (too_deep == 1) {
        add_to_console("ERROR [Dimensionality too large]. Use 1D or 2D loops for option: iteration space",'orange');
    }
    else {
        run_simulation(ast);
        if (lhs_incorrect == true) {
            add_to_console("ERROR [Incorrect assignment]. Assign to variables or arrays",'orange');
        }
        else if (variables_in_iterator.length > 0) {
            add_to_console("ERROR [Unknown variable in iterator: "+variables_in_iterator[0]+"]. Use constants or other iterators",'orange');
        }
        else if (variables_in_array.length > 0) {
            add_to_console("ERROR [Unknown variable in array call: "+variables_in_array[0]+"]. Use constants or iterators",'orange');
        }
        else if (too_deep == 1) {
            add_to_console("ERROR [Dimensionality too large]. Use 1D or 2D loops for option: iteration space",'orange');
        }
        else {
            add_to_console("Simulation done",'green');

            if (iterations_1.length != 0) {
                max_deepness = 1;
                if (iterations_2.length != 0) {
                    max_deepness = 2;
                }
            }

            // GRAPH DECL
            // create an array with nodes
            var nodes = new vis.DataSet([]);

            // create an array with edges
            var edges = new vis.DataSet([]);

            // create a network
            var container = document.getElementById('mynetwork');

            // provide the data in the vis format
            var data = {
                nodes: nodes,
                edges: edges
            };

            //nodes.on('*', function (event, properties, senderId) {});

            width = window.innerWidth - 650 - 15;

            add_to_console("Building iteration space...");
            if (max_deepness == 1 || max_deepness == 2) {
                spacing = calculate_graph_point();
                current_x = (spacing[0]+spacing[1])/2;
                if (max_deepness == 1) {
                    node_size = 25 < spacing[0]/2 ? 25 : spacing[0]/2;
                    for (i = 0; i < iterations_1.length; i++) {
                        nodes.add({id: iterations_1[i].toString(), label: iterations_1[i][0][1]+"", x: current_x, y: 265, size: node_size});
                        current_x += spacing[0]+spacing[1];
                    }
                }
                else if (max_deepness == 2) {
                    current_y = -(spacing[0][0]+spacing[1][0])/2;
                    if (spacing[0][0] < spacing[0][1]) {
                        node_size = spacing[0][0]/2;
                    }
                    else {
                        node_size = spacing[0][1]/2;
                    }
                    node_size = 25 < node_size ? 25 : node_size;
                    var rows = iterations_2.length/iterations_1.length;

                    for (i = 0; i < iterations_2.length; i++) {
                        if (i % rows == 0) {
                            current_x = (spacing[0][1]+spacing[1][1])/2;
                            current_y += spacing[0][0]+spacing[1][0];
                        }
                        nodes.add({id: iterations_2[i].toString(), label: iterations_2[i][0][1]+","+iterations_2[i][1][1], x: current_x, y: current_y, size: node_size});
                        current_x += spacing[0][1]+spacing[1][1];
                    }
                }
            }

            for (i = 0; i < raw_it.length; i ++) {
                if (!multi.has(raw_it[i].toString())) {
                    edges.add({id: raw_it[i].toString(), from: raw_it[i][0].toString(), to: raw_it[i][1].toString(), label: get_distance(raw_it[i]).toString(),  color: { color: '#FF7C23', highlight: '#FF7C23'}});
                    multi.set(raw_it[i].toString(),1);
                }
            }

            for (i = 0; i < war_it.length; i ++) {
                if (multi.get(war_it[i].toString()) == 1) {
                    edges.update({id: war_it[i].toString(), color: { color: '#B660E8', highlight: '#B660E8'}});
                    multi.set(war_it[i].toString(),10);
                }
                else if (!multi.has(war_it[i].toString())) {
                    edges.add({id: war_it[i].toString(), from: war_it[i][0].toString(), to: war_it[i][1].toString(), label: get_distance(war_it[i]).toString(), color: { color: '#5889FF', highlight: '#5889FF'}});
                    multi.set(war_it[i].toString(),2);
                }
            }

            for (i = 0; i < waw_it.length; i ++) {
                if (multi.get(waw_it[i].toString()) == 1 || multi.get(waw_it[i].toString()) == 2 ) {
                    edges.update({id: waw_it[i].toString(), color: { color: '#B660E8', highlight: '#B660E8'}});
                }
                else if (!multi.has(waw_it[i].toString())) {
                    edges.add({id: waw_it[i].toString(), from: waw_it[i][0].toString(), to: waw_it[i][1].toString(), label: get_distance(waw_it[i]).toString(), color: { color: 'red', highlight: 'red'}});
                }
            }

            var options = {
            width: width+'px',
            height: height+'px',
            nodes: {
                font: {face: 'Arvo', color: 'white', size: Math.floor(node_size*0.9)},
                color: {
                    background: '#888',
                    highlight: 'blue'
                },
                shape: 'circle',
                borderWidth: 0
            },
            edges: {
                font: {face: 'Arvo', color: '#444', size: Math.floor(node_size*0.9)},
                smooth: {
                    type: 'curvedCW',
                    forceDirection: 'none'
                },
                arrows: {
                    to: {
                        enabled: true
                    }
                },
                color: {
                    color: '#333',
                    highlight: 'red'
                }
            },
            physics: false,
            interaction: {
                dragNodes: false,
                zoomView: true,
                dragView: true
            }
            };

            network = new vis.Network(container, data, options);
            network.moveTo({
            position: {x: 0, y: 0},
            offset: {x: -Math.floor(width*0.9/2), y: -Math.floor(height*0.9/2)},
            scale: 1,
            })

            document.getElementById('labels_itspc').style.display = 'inline-block';
            document.getElementById('labels_dpgph').style.display = 'none';
            //document.getElementById('direction_vector').innerHTML = "["+direction+"]";
            add_to_console("Done",'green');
        }
    }
});

// DEPENDENCY GRAPH
document.getElementById("dg_button").addEventListener("click", function(){
    add_to_console("Running simulation with option: depdency graph...",'#c7c7c7');
    option = 2;

    // REFRESH ...

    iterators = new Map();
    reads = new Map();
    writes = new Map();
    reads_it = new Map();
    writes_it = new Map();
    current_stmt = 0;
    variables_in_array = new Array();
    variables_in_iterator = new Array();
    iterations_1 = new Array();
    iterations_2 = new Array();
    stop_the_program = false;
    clean = false;
    known_vars = new Map();
    lhs_incorrect = false;

    raw = new Array();
    war = new Array();
    waw = new Array();
    raw_it = new Array();
    war_it = new Array();
    waw_it = new Array();
    raw_map = new Map();
    war_map = new Map();
    waw_map = new Map();

    // HELP
    var cnt = 1;
    var graph_links = new Map();
    var multi = new Map();
    var deepness = 0;
    var max_deepness = 0;
    var edges_added = new Map();


    run_simulation(ast);
    if (lhs_incorrect == true) {
        add_to_console("ERROR [Incorrect assignment]. Assign to variables or arrays",'orange');
    }
    else if (variables_in_iterator.length > 0) {
        add_to_console("ERROR [Unknown variable in iterator: "+variables_in_iterator[0]+"]. Use constants or other iterators",'orange');
    }
    else if (variables_in_array.length > 0) {
        add_to_console("ERROR [Unknown variable in array call: "+variables_in_array[0]+"]. Use constants or iterators",'orange');
    }
    else {
        add_to_console("Simulation done",'green');

        // GRAPH DECL
        // create an array with nodes
        var nodes = new vis.DataSet([]);

        // create an array with edges
        var edges = new vis.DataSet([]);

        // create a network
        var container = document.getElementById('mynetwork');

        // provide the data in the vis format
        var data = {
            nodes: nodes,
            edges: edges
        };

        //nodes.on('*', function (event, properties, senderId) {});

        var width = window.innerWidth - 650 - 15;

        add_to_console("Building dependency graph...");
        for (i = 1; i <= ast.stmt_nr; i++) {
            if (stmt_register.length == 0 || stmt_register.has(i)) {
                nodes.add({id: i, label: "S"+i.toString()});
            }
        }

        for (i = 0; i < raw.length; i++) {
            if (edges_added.has(raw[i][0]+","+raw[i][1])) {
                var new_delta = edges_added.get(raw[i][0]+","+raw[i][1])+","+get_delta(raw[i][2],'raw');
                edges.update({id: raw[i][0]+","+raw[i][1], from: raw[i][0], to: raw[i][1], label: new_delta});
                edges_added.set(raw[i][0]+","+raw[i][1],new_delta);
            }
            else {
                var new_delta = get_delta(raw[i][2],'raw');
                edges.add({id: raw[i][0]+","+raw[i][1], from: raw[i][0], to: raw[i][1], label: new_delta });
                edges_added.set(raw[i][0]+","+raw[i][1],new_delta);
            }
        }

        for (i = 0; i < war.length; i++) {
            if (edges_added.has(war[i][0]+","+war[i][1])) {
                var new_delta = edges_added.get(war[i][0]+","+war[i][1])+","+get_delta(war[i][2],'war');
                edges.update({id: war[i][0]+","+war[i][1], from: war[i][0], to: war[i][1], label: new_delta});
                edges_added.set(war[i][0]+","+war[i][1],new_delta);
            }
            else {
                var new_delta = get_delta(war[i][2],'war');
                edges.add({id: war[i][0]+","+war[i][1], from: war[i][0], to: war[i][1], label: new_delta });
                edges_added.set(war[i][0]+","+war[i][1],new_delta);
            }
        }

        for (i = 0; i < waw.length; i++) {
            if (edges_added.has(waw[i][0]+","+waw[i][1])) {
                var new_delta = edges_added.get(waw[i][0]+","+waw[i][1])+","+get_delta(waw[i][2],'waw');
                edges.update({id: waw[i][0]+","+waw[i][1], from: waw[i][0], to: waw[i][1], label: new_delta});
                edges_added.set(waw[i][0]+","+waw[i][1],new_delta);
            }
            else {
                var new_delta = get_delta(waw[i][2],'waw');
                edges.add({id: waw[i][0]+","+waw[i][1], from: waw[i][0], to: waw[i][1], label: new_delta });
                edges_added.set(waw[i][0]+","+waw[i][1],new_delta);
            }
        }

        var options = {
            width: width+'px',
            height: height+'px',
            nodes: {
                font: {face: 'Arvo', color: 'white', size: 30},
                color: {
                    background: '#888',
                    highlight: 'blue',
                },
                margin:10,
                shape: 'circle',
                borderWidth: 0,
            },
            edges: {
                font: {face: 'Arvo', color: '#444', size: 25},
                smooth: {
                    type: 'curvedCW',
                    forceDirection: 'none'
                },
                arrows: {
                    to: {
                        enabled: true
                    }
                },
                color: {
                    color: '#666',
                    highlight: 'red'
                }
            },
            physics: true,
            interaction: {
                dragNodes: true,
                zoomView: true,
                dragView: true
            }
            };

        network = new vis.Network(container, data, options);

        //document.getElementById('labels_dpgph').style.display = 'inline-block';
        document.getElementById('labels_itspc').style.display = 'none';
        add_to_console("Done",'green');
    }
});

    
</script>
    
</body>
</html>