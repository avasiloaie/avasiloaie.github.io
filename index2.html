
<!DOCTYPE html>
<html>

<link rel="stylesheet" href="style.css">
    
<!-- FONTS -->
<link href="https://fonts.googleapis.com/css?family=Arvo:400,400i,700,700i" rel="stylesheet">
    
<!-- USER INPUT -->
<link rel="stylesheet" href="lib/codemirror.css">
<script src="lib/codemirror.js"></script>
<script src="collections.min.js"></script>
    
<!-- DEPENDENCY ANALYSIS -->
<script src="bundle.js"></script>
    
<!-- GRAPH RENDERING -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css">

<!-- CHROMA -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.2/jquery.min.js"></script>
<script>

var colors = new Array(
  //[62,35,255],
  //[60,255,60],
  //[255,35,98],
  //[45,175,230],
  //[255,0,255],
  //[255,128,0]
  [255,108,28],
  [232,54,48],
  [255,52,178],
  [255,170,38]);

var step = 0;
//color table indices for: 
// current color left
// next color left
// current color right
// next color right
var colorIndices = [0,1,2,3];

//transition speed
var gradientSpeed = 0.0003;

function updateGradient()
{
  
  if ( $===undefined ) return;
  
var c0_0 = colors[colorIndices[0]];
var c0_1 = colors[colorIndices[1]];
var c1_0 = colors[colorIndices[2]];
var c1_1 = colors[colorIndices[3]];

var istep = 1 - step;
var r1 = Math.round(istep * c0_0[0] + step * c0_1[0]);
var g1 = Math.round(istep * c0_0[1] + step * c0_1[1]);
var b1 = Math.round(istep * c0_0[2] + step * c0_1[2]);
var color1 = "rgb("+r1+","+g1+","+b1+")";

var r2 = Math.round(istep * c1_0[0] + step * c1_1[0]);
var g2 = Math.round(istep * c1_0[1] + step * c1_1[1]);
var b2 = Math.round(istep * c1_0[2] + step * c1_1[2]);
var color2 = "rgb("+r2+","+g2+","+b2+")";

 $('#header').css({
   background: "-webkit-gradient(linear, left top, right top, from("+color1+"), to("+color2+"))"}).css({
    background: "-moz-linear-gradient(left, "+color1+" 0%, "+color2+" 100%)"});
  
  step += gradientSpeed;
  if ( step >= 1 )
  {
    step %= 1;
    colorIndices[0] = colorIndices[1];
    colorIndices[2] = colorIndices[3];
    
    //pick two new target color indices
    //do not pick the same as the current one
    colorIndices[1] = ( colorIndices[1] + Math.floor( 1 + Math.random() * (colors.length - 1))) % colors.length;
    colorIndices[3] = ( colorIndices[3] + Math.floor( 1 + Math.random() * (colors.length - 1))) % colors.length;
    
  }
}

setInterval(updateGradient,10);
</script>
    
<style type="text/css">
    #mynetwork {
        width: 100%;
        height: 600px;
        border: 2px solid lightgray;
        display:inline-block;
        margin:10px 0px 10px 0;
    }
</style>
    
<body>
    
<div id="header">
    <div id="header_left">
        <div id="title">Compiler Dependency</div>
        <div id="desc">> Sandbox Tool</div>
    </div>
    <div id="header_right">
        <ul>
            <li><a href="">Sample Page 1</a></li>
            <li><a href="">Sample Page 2</a></li>
            <li><a href="">Sample Page 3</a></li>
            <li><a href="">Sample Page 4</a></li>
        </ul>
    </div>
</div>
    
<div id="wrapper">
    
<div id="editor">
    <div id="code"></div>
    <button id="run_button">Run</button>
</div>
    
<div id="printer">
    <div id="mynetwork"></div>
    <div id="labels">
        <div style="display:inline-block; margin-right:10px; font-weight:bold;">Labels:</div>
        <div style="width:20px; height:20px; background-color:#FF7C23; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">Read</div>
        <div style="margin-left:15px; width:20px; height:20px; background-color:#5889FF; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">Write</div>
        <div style="margin-left:15px; width:20px; height:20px; background-color:#B660E8; display: inline-block;"></div><div style="display:inline-block; margin-left:5px;">Read/Write</div>
        <div id="text_before_direction_vector">Direction vector:</div><div id="direction_vector"><i>n/a</i></div>
    </div>
</div>
    
    
</div>
<div id="footer"></div>
    
<script type="text/javascript">   
    
var $editor = CodeMirror(document.getElementById('code'), {
  value: "INPUT CODE HERE...",
  mode:  "javascript",
  lineNumbers: true
});
    
document.getElementById("run_button").addEventListener("click", function(){
    var input = $editor.getValue();
    input += '\n';
    var ast = parse_routine(input);
    
    function Memory(id,indices,key) {
    this.id = id;
    this.indices = indices;
    this.key = key;
    var state;
}

function evaluate(expr) { // A(expr,expr) -> evaluates expr for current iteration
    var type = expr.type;
    var op = expr.op;
    var lhs = expr.lhs;
    var rhs = expr.rhs;

    if ( type == "op" ) {
        if (lhs == null) {
            if (op == "-") return -evaluate(rhs);
            else if (op == "+") return evaluate(rhs);
            // else console.log("Not a valid operation: "+expr);
        }
        else {
            if (op == "+") return evaluate(lhs) + evaluate(rhs);
            else if (op == "-") return evaluate(lhs) - evaluate(rhs);
            else if (op == "*") return evaluate(lhs) * evaluate(rhs);
            else if (op == "/") return evaluate(lhs) / evaluate(rhs);
            else if (op == "%") return evaluate(lhs) % evaluate(rhs);
            else if (op == ".LT.") return evaluate(lhs) < evaluate(rhs);
            else if (op == ".LE.") return evaluate(lhs) <= evaluate(rhs);
            else if (op == ".GT.") return evaluate(lhs) > evaluate(rhs);
            else if (op == ".GE.") return evaluate(lhs) >= evaluate(rhs);
            else if (op == ".EQ.") return evaluate(lhs) == evaluate(rhs);
            else if (op == ".NE.") return evaluate(lhs) != evaluate(rhs);
            else if (op == ".OR.") return evaluate(lhs) || evaluate(rhs);
            else if (op == ".AND.") return evaluate(lhs) && evaluate(rhs);
            //else console.log("Not a valid operation: "+expr);
        }
    }
    else if ( type == "val" ) {
        return expr.val;
    }
    else if (type == "var" ) {
        if (iterators.has(expr.variable)) return iterators.get(expr.variable);
        else return 10;
    }
    else if (type == "array") {
        return 0;
    }
    else {
        //console.log("Not a valid expr: "+expr); 
    }
}

function simulate_expr(expr,side) {
    if (expr.type == "array") {
        var memory = get_memory(expr);
        memory.state = iterators.clone();
        if (side == "lhs") writes.push(memory); 
        else if (side == "rhs") reads.push(memory);
    }
    else if (expr.type == "op") {
        simulate_expr(expr.lhs,side);
        simulate_expr(expr.rhs,side);
    }
}

function simulate_stmts(stmt_list) {
    for (var i = 0; i < stmt_list.length; i++) {
        var stmt = stmt_list[i];
        if (stmt.type == "do") {
            simulate_do(stmt);
        }
        else if (stmt.type == "assign") {
            var wr = writes.length;
            var rd = reads.length;
            simulate_expr(stmt.lhs,"lhs");
            simulate_expr(stmt.rhs,"rhs");
            link_stuff(writes.slice(wr-writes.length),reads.slice(rd-reads.length));

        }
        else if (stmt.type == "if") {
            if (evaluate(stmt.expr)) {
                simulate_stmts(stmt.if_part);
            }
            else if (stmt.else_if_part != null) {
                for (i = 0; i < stmt.else_if_part.else_if_list.length; i ++) {
                    if (evaluate(stmt.else_if_part.else_if_list[i].expr)) {
                        simulate_stmts(stmt.else_if_part.else_if_list[i].stmt_list);
                        break;
                    }
                }
            }
            else if (stmt.else_part != null) {
                console.log(stmt.else_part);
                simulate_stmts(stmt.else_part.stmt_list);
            }
        }
    }
}

function simulate_do(do_stmt) {
    var it = do_stmt.it;
    iterators.set(it,evaluate(do_stmt.start));
    var step;
    if (do_stmt.step == null) step = 1;
    else { step = evaluate(do_stmt.step); }

    if (iterators.get(it) > evaluate(do_stmt.end)) {
        if (step > 0) { step = -step; }

        while (iterators.get(it) >= evaluate(do_stmt.end) ) {
            simulate_stmts(do_stmt.stmt_list);
            var next_step = iterators.get(it)+step;
            iterators.set(it,next_step);
        }
    }
    else {
        while (iterators.get(it) <= evaluate(do_stmt.end) ) {
            simulate_stmts(do_stmt.stmt_list);
            var next_step = iterators.get(it)+step;
            iterators.set(it,next_step);
        }
    }
}

function get_memory(array_call) { // eg A(i,j) with i = 5, j = 2 -> MEM(A:5,2)
    var id = array_call.id;
    var indices = [];
    var key = "";

    var key = "MEM(" + id + ":";

    for (var i = 0; i < array_call.index_list.length; i++) {
        current_index = evaluate(array_call.index_list[i]);
        indices.push(current_index);
        key += current_index + ",";
    }

    key = key.substring(0,key.length-1);
    key += ")";

    for (i = 0; i < indices.length; i ++) {
        if (max_dimension[i] < indices[i]) {
            max_dimension[i] = indices[i];
        }
        if (min_dimension[i] > indices[i]) {
            min_dimension[i] = indices[i];
        }
        if (i == 2) {
            break;
        }
    }

    return new Memory(id,indices,key);
}

var elem_map = new Map();

function Elem(id,indices,to) {
    this.id = id;
    this.indices = indices;
    this.to = to;
}

function link_stuff(writes,reads) {
    if (writes.length != 0 && reads.length != 0) {
        var wr = writes[0];
        var rd;

        if (!elem_map.has(wr.key)) {
            elem_map.set(wr.key,new Elem(wr.id,wr.indices,[]));
        }

        for (var i = 0; i < reads.length; i ++) {
            rd = reads[i];
            if (!elem_map.has(rd.key)) {
                elem_map.set(rd.key,new Elem(rd.id,rd.indices,[]));
            }
            var elem = elem_map.get(rd.key);
            elem.to.push([elem_map.get(wr.key),calculate_distance(wr.indices,rd.indices)]);
        }
    }
}

function calculate_distance(wr,rd) {
    var distances = [];
    for (var i = 0; i < wr.length; i++) {
        distances.push(wr[i]-rd[i]);
    }
    return distances;
}

function no_of_dims() {
    if (max_dimension[2] != -1) return 3;
    if (max_dimension[0] != -1){
        if (max_dimension[1] != -1) return 2;
        return 1;
    }
    return 0;
}

function get_direction() {
    var elems = elem_map.toArray();
    var n = elems[0].indices.length;
    var distance_vector;
    var first = true;
    var result = [];
    var star = [];
    
    for (i = 0; i < elems.length; i ++) {
        if (elems[i].to.length != 0) {
            if (first) {
                distance_vector = elems[i].to[0][1];
                first = false;
            }
            for (var j = 0; j < elems[i].to.length; j ++) {
                for (var k = 0; k < distance_vector.length; k++) {
                    if (distance_vector[k] != elems[i].to[j][1][k]) {
                        star[k] = true;
                    }
                }
            }
        }
    }
    for (i = 0; i < n; i++) {
        if (star[i] == true) { result[i] = '*'; }
        else if ( distance_vector[i] == 0 ) { result[i] = '='; }
        else if ( distance_vector[i] > 0 ) { result[i] = '>'; }
        else { result[i] = '<'; }
    }
    return result;
}

function run_simulation(ast) {
    simulate_stmts(ast.stmt_list);
}

function calculate_graph_point() {
    var node_itself = [];
    var distance_in_between = [];

    if (dimensions == 1) {
        diff = max_dimension[0]-min_dimension[0];
        space_per_node = Math.floor((width*0.9)/(diff+1));
        node_itself[0] = Math.ceil(space_per_node*0.7);
        distance_in_between[0] = Math.floor(space_per_node*0.3);
        return [node_itself[0],distance_in_between[0]];
    }
    else if (dimensions == 2) {
        diff = max_dimension[0]-min_dimension[0];
        space_per_node = Math.floor((height*0.9)/(diff+1));
        node_itself[0] = Math.ceil(space_per_node*0.4);
        distance_in_between[0] = Math.floor(space_per_node*0.6);
        diff = max_dimension[1]-min_dimension[1];
        space_per_node = Math.floor((width*0.9)/(diff+1));
        node_itself[1] = Math.ceil(space_per_node*0.7);
        distance_in_between[1] = Math.floor(space_per_node*0.3);
        return [node_itself,distance_in_between];
    }   
    return null;
}
    
    var iterators = new Map();

    var max_dimension = [ [-1],[-1],[-1]];
    var min_dimension = [ [100000],[100000],[100000]];

    var links = [];
    var writes = [];
    var reads = [];
    var iteration_space;
    var dimensions;
    var direction;
    var i;
    var j;
    var cnt = 1;
    var spacing
    var current_x;
    var current_y;
    var width;
    var height = 600;
    var node_size;
    var graph_links = new Map();
    var multi = new Map();
    
    run_simulation(ast);
    dimensions = no_of_dims();
    if (max_dimension[0] != -1) {
        direction = get_direction();
    }
    else {
        direction = null;
    }

    // create an array with nodes
    var nodes = new vis.DataSet([]);

    // create an array with edges
    var edges = new vis.DataSet([]);

    // create a network
    var container = document.getElementById('mynetwork');

    // provide the data in the vis format
    var data = {
        nodes: nodes,
        edges: edges
    };

    //nodes.on('*', function (event, properties, senderId) {});

    var width = window.innerWidth - 650 - 15;
    
    if (dimensions == 1 || dimensions == 2) {
        spacing = calculate_graph_point();
        current_x = (spacing[0]+spacing[1])/2;
        if (dimensions == 1) {
            node_size = 25 < spacing[0]/2 ? 25 : spacing[0]/2;
            for (i = min_dimension[0]; i <= max_dimension[0]; i++) {
                nodes.add({id: cnt, label:i+"", x: current_x, y: 265, size: node_size});
                graph_links.set(i+"",cnt);
                current_x += spacing[0]+spacing[1];
                cnt++;
            }
        }
        else {
            current_y = (spacing[0][0]+spacing[1][0])/2;
            if (spacing[0][0] < spacing[0][1]) {
                node_size = spacing[0][0]/2;
            }
            else {
                node_size = spacing[0][1]/2;
            }
            node_size = 25 < node_size ? 25 : node_size;
            for (i = min_dimension[0]; i <= max_dimension[0]; i++) {
                current_x = (spacing[0][1]+spacing[1][1])/2;
                for (j = min_dimension[1]; j <= max_dimension[1]; j++) {
                    nodes.add({id: cnt, label:i+","+j, x: current_x, y: current_y, size: node_size});
                    graph_links.set(i+","+j,cnt);
                    current_x += spacing[0][1]+spacing[1][1];
                    cnt++;
                }
                current_x = (spacing[0][1]+spacing[1][1])/2;
                current_y += spacing[0][0]+spacing[1][0];
            }
        }
    }

    var elems = elem_map.toArray();
    var from;
    var from_reformed;
    var to;
    var to_reformed;
    for (i = 0; i < elems.length; i++) {
        if (dimensions == 1) {
            from = elems[i].indices[0];
            from_reformed = graph_links.get(from+"");
            for (j = 0; j < elems[i].to.length; j++) {
                to_reformed = graph_links.get(elems[i].to[j][0].indices[0]+"");
                edges.add({from: from_reformed, to: to_reformed, label: elems[i].to[j][1]+"" })
                if (multi.get(from_reformed) == null) {
                    nodes.update({id: from_reformed, color: '#FF7C23'})
                    multi.set(from_reformed,1);
                }
                else if (multi.get(from_reformed) == 2) {
                    nodes.update({id: from_reformed, color: '#B660E8'})
                    multi.set(from_reformed,3);
                }
                if (multi.get(to_reformed) == null) {
                    nodes.update({id: to_reformed, color: '#5889FF'})
                    multi.set(to_reformed,2);
                }
                else if (multi.get(to_reformed) == 1) {
                    nodes.update({id: to_reformed, color: '#B660E8'})
                    multi.set(to_reformed,3);
                }

            }
        }
        else if (dimensions == 2) {
            from = elems[i].indices;
            from_reformed = graph_links.get(from[0]+","+from[1]);
            for (j = 0; j < elems[i].to.length; j++) {
                to = elems[i].to[j][0].indices;
                to_reformed = graph_links.get(to[0]+","+to[1]);
                edges.add({from: from_reformed, to: to_reformed, label: elems[i].to[j][1]+""});

                if (multi.get(from_reformed) == null) {
                    nodes.update({id: from_reformed, color: '#FF7C23'})
                    multi.set(from_reformed,1);
                }
                else if (multi.get(from_reformed) == 2) {
                    nodes.update({id: from_reformed, color: '#B660E8'})
                    multi.set(from_reformed,3);
                }
                if (multi.get(to_reformed) == null) {
                    nodes.update({id: to_reformed, color: '#5889FF'})
                    multi.set(to_reformed,2);
                }
                else if (multi.get(to_reformed) == 1) {
                    nodes.update({id: to_reformed, color: '#B660E8'})
                    multi.set(to_reformed,3);
                }
            }
        }
    }

    var options = {
    width: width+'px',
    height: height+'px',
    nodes: {
        font: {face: 'Arvo', color: 'white', size: Math.floor(node_size*0.85)},
        color: 'lightgray',
        shape: 'circle',
        borderWidth: 1,
    },
    edges: {
        font: {face: 'Arvo', color: '#444', size: Math.floor(node_size*0.85)},
        smooth: {
            type: 'curvedCW',
            forceDirection: 'none'
        },
        arrows: {
            to: {
                enabled: true
            }
        },
        color: {
            color: 'darkgrey'
        }
    },
    physics: false,
    interaction: {
        dragNodes: false,
        zoomView: true,
        dragView: true
    }
    };

    var network = new vis.Network(container, data, options);
    network.moveTo({
    position: {x: 0, y: 0},
    offset: {x: -Math.floor(width*0.9/2), y: -Math.floor(height*0.9/2)},
    scale: 1,
    })

    //console.log(nodes);
    /*console.log(elem_map);
    console.log(min_dimension);
    console.log(max_dimension);
    console.log(direction);
    console.log(dimensions);*/
    
    document.getElementById('direction_vector').innerHTML = "["+direction+"]";
});

    
</script>
    
</body>
</html>